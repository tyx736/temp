A Guide to ZK Coprocessors for Scalability

KAYLEI ATCHLEY
GUEST WRITER
October 19, 2023
If you’re operating an on-chain application, a ZK Coprocessor is a key tool for allowing you to scale your on-chain logic while keeping gas costs low. In this post, we review what a coprocessor is, why it matters, and how you can use the Bonsai ZK coprocessor architecture to scale your application.

‍

Computational Limitations of On-chain Applications
Having your application execute entirely on the EVM comes with drawbacks. Tasks requiring heavy computation or large stores of data require gas fees so high that using your application can quickly become cost prohibitive. This means certain features are not realistically possible on the EVM, limiting the potential of your applications.

The trick is to move computation off-chain, drastically reducing gas fees and making your application more attractive to users. Traditionally, this would require trusting the computation executed on a centralized server, sacrificing the verifiable ecosystem of Ethereum in the name of cost savings. Fortunately, ZK proofs provide a way to securely verify these off-chain results while maintaining core values of decentralization, and at a fraction of on-chain costs.

‍

Entering the Chat: Bonsai ZK Coprocessor
The Bonsai ZK Coprocessor Architecture extends the capabilities of on-chain applications with programmable & verifiable off-chain computation. Instead of spinning up your own ZK infrastructure, you can upload the program and request that Bonsai generate proofs on demand.


The Bonsai ZK Coprocessor Architecture is powered by connecting our zkVM and Bonsai with Ethereum using our ETH Relay. This enables us to extend the functionality of Ethereum smart contracts by allowing applications to port logic into Rust and execute the logic off-chain on Bonsai.


One important callout is that Bonsai isn’t restricted to Ethereum. Any blockchain that possesses an execution and consensus layer can harness the Bonsai coprocessor to shift execution or computation off-chain.

A few examples include:

Optimistic Layer 2, such as Optimism and Arbitrum
ZK Layer 2, like Starkware and ZKSync
EVM Layer 1, including Avalanche and Polygon
Non-EVM Layer 1, encompassing Solana and Aptos
Cosmos interchains
‍

What is a Coprocessor?
A coprocessor serves as a companion to a processor, allowing for off-loading computation in a resource-constrained system. For example, running an AI model like ChatGPT on your cell phone would be unfeasible. Your phone is slow, has limited storage, you’re paying to download the massive model, and your battery life is limited. However, when you ask ChatGPT a question, it’s sent to a dedicated server where it can run cheaply and efficiently then send back an answer. In this way, ChatGPT’s servers are acting as an AI co-processor for your cell phone’s limited resources.


On the other hand, the EVM serves as a versatile platform capable of executing various operations. Analogous to a personal device, the EVM can handle diverse tasks but might not always be the most efficient for high-volume operations. And zkVM, much like a cloud computer or mainframe, is designed for general-purpose tasks but excels in speed and cost-effectiveness.

‍

Bonsai ZK Coprocessor’s Architecture

Call Bonsai, specifying which program and inputs to execute. You can call Bonsai in one of two ways:
- Call Bonsai from Ethereum: call the BonsaiRelay contract from your smart contract.
- Call Bonsai from off-chain: call Bonsai using the REST API.
Bonsai executes your program off-chain on the zkVM with the inputs you provided.
Bonsai sends a proof of the executed program back to BonsaiRelay.
The proof is checked by an on-chain verifier.
Your contract receives the verified result.
Bonsai massively reduces gas fees and expands the capabilities of on-chain applications — slicing through price barriers for your users while providing developers with wider opportunities. This architecture allows you to move the expensive parts of you application, even the entire logic, out of your Solidity smart contracts and into a Rust program that executes off-chain.

‍

Use cases for ZK coprocessors
Many applications, such as on-chain gaming or central limit order books, need off-chain computation to be economical. However, any application logic requiring more than 250K gas can potentially reduce costs with ZK coprocessors.

DAOs are a perfect example of collective on-chain activity involving many actors and multiple smart contracts and leading to heavy computation. ZK Coprocessors for DAO governance ensure off-chain compute for cheaper gas, and verification of on-chain data among parties. With the Bonsai DAO Governor, DAO members were able to lower their gas fees by more than 50% (from $6-9, to just $2-3 per vote during July 23rd) by moving compute off-chain. We’ll release more on how we built the Bonsai Governor soon!

Another notable use-case includes Web2 to Web3 verification. For example, Bonfire Wallet allows users to create a burner wallet using WebAuthn, while Bonsai ZK Coprocessor handles off-chain compute.


‍

Build with Bonsai
To use Bonsai as a coprocessor for Ethereum, all you need to do is:

Write a zkVM application that handles your app logic
Write a Solidity contract that asks Bonsai to run your zkVM app and what to do with the results
Then, follow the instructions in the deployment guide.

Bonsai can help whether you're looking to take heavy computations off-chain or need to generate proofs for your trustless, verifiable software. For any questions, reach out to our team on Discord!


由于区块链为了保护安全，而施加了计算限制，ZK协处理器(Coprocessors)正逐渐成为一个备受关注的话题。它能够增强计算能力，同时保持强大的安全性。在本文中，Galaxy Digital 研究员 E 将探讨ZK协处理器的概念、作用以及正在构建的一些项目。

一般来说，协处理器是一种专门的组件，它协助CPU，通过更熟练地处理某些任务来提高计算机系统的整体效率和速度。

ZK协处理器是一个互操作层，它执行任意计算并提供一个“收据”，这是确认计算正确执行的数学有效证明。

每个收据都包括一个加密标识符，表示执行了哪个计算，并记录计算的任何公共输出。

有了这些收据，机器可以明确地“证明”计算发生了。这不仅仅是说明计算发生了，还提供了一个可验证的轨迹。这就像一个无需信任的、安全的计算审计！

为什么我们需要ZK协处理器？

区块链对计算能力施加了限制，将L1/L2上的操作限制在一小部分固有安全操作中以确保安全。ZK协处理器增强了计算能力，使得在保持强大安全性的同时能够执行更广泛的操作。

正在构建的zk协处理器的协议有哪些？

Axiom 是以太坊的 ZK 协处理器，它为智能合约提供了对所有链上数据的无需信任的访问以及对其进行任意表达式计算的能力。

Axiom对于任何协议或去中心化应用（dapp）都有用，只要其中涉及历史链上数据或表达式计算，包括无需信任的会计、动态DeFi、无需信任的链下治理以及无需信任的链上预言机等。

Axiom的使命是使零知识证明的功能在链上应用中尽可能地易于访问和使用，从而解锁一波更丰富、更具表现力的信任最小化去中心化应用的新浪潮。

Tanuki 利用Axiom为基于历史链上数据的钱包评分计算提供了一个无需信任、透明的系统。这些数据可以用于信用评分协议，如Karma3labs，NFT定价分析，如SPICYEST等。

Tanuki 的解决方案是一种去中心化的替代方案，使协议能够以无需信任的方式计算相关指标，从而促进公平和透明的互动。传统上，这些计算只能在中心化且不太透明的系统中进行。

Risc Zero提供了一个可以在任何平台上运行的zkVM。它是一个虚拟微控制器/协处理器，为其运行的每个程序生成收据，有点像一个安全的虚拟Adruino。

RiscZero的Bonsai是一个通用的零知识证明网络。它提供了为区块链智能合约执行链下计算的能力。

Herodotus 旨在为智能合约提供来自其他以太坊层的同步链上数据访问。他们认为存储证明可以统一多个Rollups的状态，甚至允许以太坊层之间的同步读取。

Poseidon ZKP 旨在填补创建EVM原生zkDApps的空白。它针对以隐私为中心的zkDApps开发的两个主要障碍：由于加密复杂性而使使用ZKP的高门槛，以及昂贵的链上验证。

Poseidon ZKP 正在开发的一个功能涉及将可组合的ZKP原语作为智能合约创建。在此基础上，他们提供了一个ZK-ZK聚合器，将一批客户端生成的证明，并合并为一个证明，显著降低了摊销后的ZKP验证成本。

另一个由Devloper共同创立且低调的项目Pluto，正在探索如何为特定于dApp的可扩展性创建无缝的开发者体验。

准备好让您的dApps在效率和安全性方面达到新的高度吗？拥抱zk协处理器的未来，开启无尽的可能性。



Brevis: A Smart ZK Coprocessor for Blockchains
Celer Network
CELR

CelerNetwork
By CelerNetwork

Created 7 months ago, last updated 2 months ago
•
15 mins read
Brevis: A Smart ZK Coprocessor for Blockchains
Table of Contents
TL;DR
Web3 dApps are Missing Out on the Value of Utilizing Omnichain Data
Zero-Knowledge Succinct Proofs: The Magic of Computation Migration
Brevis System Overview
An Example Walkthrough
zkFabric PoC: Ethereum PoS, Cosmos Tendermint, BNB Chain Light Client ZK Circuits and ZK Bridge
Numerous Exciting Use Cases Enabled by Brevis
Data-driven DeFi
User Acquisition with Trust-Free Revenue Sharing
zkDID
Account Abstraction
TL;DR
Web 2.0 applications often operate as walled gardens with limited data interoperability, resulting in user lock-in and fragmented identities. Web3 decentralized applications (dApps) built on top of blockchains have the potential to overcome these issues. However, smart contracts, which are the core of dApps, currently lack a trust-free way to access and utilize the vast amount of data stored in the full history of multiple blockchains. To address this limitation, we’re introducing you to Brevis, a smart Zero-Knowledge (ZK) coprocessor for blockchains that enables dApps to access, compute, and utilize arbitrary data across multiple blockchains in a completely trust-free way.

Brevis's architecture consists of three components: zkFabric, zkQueryNet, and zkAggregatorRollup. zkFabric collects block headers from all of the connected blockchains and generates Consensus Proofs that attest to the validity of these block headers via ZK light client circuits. This is essential for dApps to be able to access the block headers and all of the states from all supported blockchains in a trust-free way. zkQueryNet is an open marketplace of ZK Query Engines that can accept data queries from on-chain smart contracts directly and is able to generate the query results and corresponding ZK Query Proofs via the ZK Query Engine circuits. These engines range from highly specialized, such as calculating the trading volume of a DEX during a specific time period, to highly generalized with data indexing abstractions and high-level query languages, catering to a diverse set of application requirements. zkAggregatorRollup is a specialized ZK rollup that acts as the aggregation and storage layer for zkFabric and zkQueryNet. It verifies the proofs from both of these components, stores the attested data, and commits its zk-attested state roots to all connected blockchains, allowing dApps to access the attested query results directly in their on-chain smart contracts’ business logic.

With this modularized architecture, Brevis enables fully trust-free, flexible and highly efficient data access and computation capabilities across all supported chains for on-chain smart contracts. This enables entirely new paradigms for dApp development. Brevis has a wide range of use cases like data-driven DeFi, zkBridges, on-chain user acquisition, zkDIDs, social account abstraction, and much more.

In the initial Proof of Concept for Brevis, we built some of the fastest ZK light client circuits as parts of zkFabric with gnark for Ethereum PoS, Cosmos, and BNB Chain to enable any EVM and non-EVM chains to access the states of these three chains in a completely trust-free way. Some of the key circuit performance benchmark numbers are summarized in Table 1 (using a Linux Server with 20 cores@2.3GHz and 384GB of memory with no GPU acceleration). Using these ZK light client circuits, we implemented a user-facing asset zkBridge between Ethereum Goeril and BNB Chain Testnet for users to try out.
For a more in-depth description of Brevis, continue reading this blog or you can refer to our Brevis White Paper for more comprehensive and technical details.
Subscribe
Join us in showcasing the cryptocurrency revolution, one newsletter at a time. Subscribe now to get daily news and market updates right to your inbox, along with our millions of other subscribers (that’s right, millions love us!) — what are you waiting for?

Web3 dApps are Missing Out on the Value of Utilizing Omnichain Data
Web 2.0 applications have revolutionized user interaction and content generation on the internet. However, these applications often operate as walled gardens, with user data stored in centralized databases controlled by platform providers. This leads to challenges such as limited data interoperability, fragmented identities, financial and social data lock-ins, and subsequent issues like hindered innovation, vendor lock-in, privacy issues, and fragmented user experiences.

Web3 decentralized applications (dApps) have the potential to break these information silos by being built on top of blockchains, which have append-only and publicly accessible data storage. With the multi-blockchain expansion and adoption of dApps continuing to grow, L1 blockchains and L2 rollups have accumulated a wealth of raw data, such as asset transfers, contract function calls, in-contract events, and blockchain state roots. With all of this data, it makes it possible to extract valuable information such as ownership of assets, user activity profiles, social graphs, financial connections, market pricing trends, trading volumes and much more.

Many off-chain products and projects are already leveraging this unique property of publicly accessible data storage. Products like Dune Analytics and Graph provide off-chain data indexing or data analytics for blockchain applications across time. They can also be used to provide stateful data, such as user transaction history for dApps' frontend UIs. These applications access blockchain data in an off-chain way, recording, indexing, and computing data via the blockchain nodes' RPC endpoints.
Intuitively, on-chain blockchain applications or smart contracts should be able to easily access and utilize these omnichain data insights in their business logic in a completely trust-free way, since all of these dApps are the “native residents” inside of the blockchains.
However, this is not the case.

In reality, Web3 dApps simply have no way to access the vast majority of the data stored in blockchains in a trust-free way. This is because smart contracts deployed on a single blockchain are living in the context of blockchain virtual machines and can only access data:
via explicitly defined interfaces of other smart contracts;
That is on the same blockchain;
Only in the most current state of the blockchain instead of with a complete historical view.
One might argue that solutions, such as parsing and computing data query semantics directly in smart contracts or validating consensus algorithms with pure smart-contract-based trust-free light clients, are in theory possible. However, these approaches are infeasible due to the high on-chain computation costs. Off-chain Oracle solutions can be used, but they require additional reliance on external Oracle security for data validity.

So, how can we allow smart contracts to access and compute data from any blockchain over an arbitrary period of time?

Zero-Knowledge Succinct Proofs: The Magic of Computation Migration
Zero-knowledge succinct proof technology (ZKP) is an emerging field in cryptography with the potential to transform our digital interactions. It allows one party to prove the validity of a computation to another without revealing any information about the input value. The verifying party only needs to run a computationally inexpensive program, called a verifier, to confirm the computation's accuracy.
ZKP not only offers privacy benefits but also enables the migration of computation from high-cost per unit locations to low-cost per unit locations. The prover performs a computationally expensive operation to complete the computation and generate a cryptographic proof, while the verifier runs a cheaper operation to validate the proof. This process shifts the computation location from verifier to prover, making it a worthwhile tradeoff if the prover's unit computational costs are substantially lower than those of the verifier. This computation migration property is the driving force behind many ZK rollups. We will also leverage this property to design Brevis.

Brevis System Overview
As shown in Figure 1, Brevis's architecture consists of three main components: zkFabric, zkQueryNet, and zkAggregatorRollup. zkFabric collects block headers from all of the connected blockchains and generates ZK Consensus Proofs that attest to the validity of these block headers. These block headers are further zk-verified and stored in zkAggregatorRollup. zkQueryNet accepts data queries from dApps and generates ZK Query Proofs based on the attested block headers stored in zkAggregatorRollup. These query results are also zk-verified and stored in zkAggregatorRollup. Essentially, zkAggregatorRollup is a ZK rollup that acts as the aggregation and storage layer for zkFabric and zkQueryNet. By committing its zk-attested state roots to all Brevis connected blockchains, zkAggregatorRollup allows dApps to access attested query results and utilize them directly in their on-chain smart contract logic in a completely trust-free way.
With this high-level overview in mind, let’s walk through each component.

First, in order to utilize arbitrary data across multiple blockchains, dApps need to have a trust-free way to access the block headers from blockchains other than their native chain. This is because block headers contain state roots that can be used to access the data and states of the blockchains. To fulfill this need, zkFabric is introduced to generate ZK Consensus Proofs for block headers of all the supported chains. A Consensus Proof is generated by a light client circuit proving that the block header in question is generated according to the consensus rule of the corresponding blockchain. zkFabric itself is a decentralized system consisting of a network of block header relayers and provers.
To actually extract valuable information from the zk-attested block headers, zkQueryNet is built as an open marketplace of ZK Query Engines that directly interface with dApp developers and smart contracts. A dApp developer can choose a ZK Query Engine that fits their needs and then write queries via high-level APIs in smart contracts.
At run time, a smart contract can call the Agent Smart Contract of zkQueryNet targeting a specific ZK Query Engine. This query will be picked up by the provers of this ZK Query Engine. Using the already zk-attested block headers provided by zkFabric, the ZK Query Engine can then compute the query results and generate a ZK Query Proof attesting that computation is done correctly.

Different ZK Query Engines can have very different APIs ranging from generalized query languages to highly specific function calls with a fixed number of parameters. For example, on one side of the spectrum, a specific ZK Query Engine may only expose a function that accepts two block numbers and two chain IDs that will return the Time Weighted Average Price for the ETH/USDC pair during a specified time period on Uniswap for the specified two blockchains. On the other hand, a generalized ZK Query Engine can present developers with a blockchain indexing abstraction using high-level database queries such as SQL or GraphQL, which is very much like what they can do in off-chain data solutions such as Dune Analytics and Graph.

Brevis will provide a set of ZK Query Engines that address many immediate use cases with reasonable flexibility and high performance. As zkQueryNet is an open marketplace, we expect dApp developers and other third parties to provide other ZK Query Engines to better serve a diverse ecosystem of applications.

Finally, zkAggregatorRollup is a ZK rollup blockchain powered by a lightweight ZK virtual machine that aggregates different proofs and their inputs from zkQueryNet and zkFabric. Specifically, zkAggregatorRollup VM runtime has the following functionalities:
Recursively verify proofs generated by zkQueryNet and zkFabric;
Store the zk-verified block headers from zkFabric;
Store queries and the zk-verified results.
When plugging in a ZK Query Engine or adding a new type of consensus, zkAggregatorRollup will be extended to support the verification of the corresponding ZK proofs. Moreover, unlike many ZK rollup chains where the proofs of state root progression are only committed to a single blockchain, zkAggregatorRollup's state root proofs are committed to all the blockchains supported by Brevis.
With zkAggregatorRollup's state roots available on all connected chains, smart contracts can access the query results and block headers via data inclusion proofs. The primary benefit of using zkAggregatorRollup as an aggregation point is to reduce the block header communication or verification overhead from O(N^2) to O(N) (where N is the number of blockchains supported by Brevis), and to share query results on-demand and efficiently across all connected blockchains.

To sum up, Brevis has the following key advantages:

Trust-free: Brevis does not rely on any off-chain party to attest data and computation integrity. Instead, it relies solely on ZK succinct proofs. Therefore, applications using Brevis do not need to accept any additional trust assumptions other than those of the underlying blockchains and cryptographic protocols.
Omnichain: Brevis integrates with multiple blockchains running on different consensuses and therefore enables omnichain data access and computation.
Modularized: Brevis uses a highly modularized design in its zkQueryNet and therefore can cater to a wide range of application requirements through different flavors and implementations of ZK Query Engines.
Low-cost: Brevis's zkAggregatorRollup essentially works as a batching and aggregation layer for block headers and query results. Therefore, zkAggregatorRollup significantly reduces the on-chain costs by orders of magnitude by removing the otherwise N-to-N communication overhead and by enabling cross-chain and cross-application query results sharing.
It is important to note that the key difference between Brevis and off-chain data indexing solutions such as Dune Analytics and Graph is that Brevis can generate zk-attested query results that can be directly utilized by the business logic of on-chain smart contracts in a trust-free way. Compared to off-chain solutions whose data results can only be used in the web2-based data analytic context.

An Example Walkthrough

Before we discuss a wide range of application use cases, we present a concrete application example to provide an overview of Brevis. Note that this overview abstracts some key details and we refer readers to the full white paper for more details.

Multi-blockchain decentralized exchanges (DEXes), such as PancakeSwap, often need to dynamically adjust farming rewards for incentivized pools based on trading pair quality scores such as average daily volume, 14-day volume, price volatility, number of active traders, and liquidity providers across all supported blockchains.

Currently, such adjustments must be made through governance proposals, which entail significant human overhead and can only be done when the setting deviates severely from optimal. This causes things to lag behind market trends and often leads to a decline in user engagement, revenue loss, and a waste of treasury funds due to suboptimal reward configurations.

Brevis can address these challenges by enabling DEXes to adjust the liquidity farming schedule programmatically and in a trust-free way based on omnichain market trends. For simplicity, let us assume that volume is all we care about. Let’s also assume that there is a ZK Query Engine 𝑄 in zkQueryNet that provides a set of highly optimized circuits for DEX volume data with an API that looks like the following:

uint_64 get_trading_volume(uint_64 chain_id,
uint_64 start_block,
uint_64 end_block,
address pair)
Figure 2 shows the step-by-step process of how this use case works. To use this data compute API, the DEX smart contract first needs to make a function call to the Agent Smart Contract (denoted as 𝐴) of zkQueryNet with the above query parameters specified. Note that this function is asynchronous and only immediately returns a 𝑞𝑢𝑒𝑟𝑦_𝑖𝑑 so the DEX's smart contract needs to remember this ID and has a handler to process the return value later.
This function call is then picked up by 𝑄's prover, denoted by 𝑃_𝑞. Using the block headers for 𝑐ℎ𝑎𝑖𝑛_𝑖𝑑 (which has already been verified and stored in zkAggregatorRollup), 𝑃_𝑞 will generate a ZK proof 𝜋 proving that on 𝑐ℎ𝑎𝑖𝑛_𝑖𝑑 during the time period from 𝑠𝑡𝑎𝑟𝑡_𝑏𝑙𝑜𝑐𝑘 to 𝑒𝑛𝑑_𝑏𝑙𝑜𝑐𝑘 the DEX's 𝑡𝑟𝑎𝑑𝑖𝑛𝑔_𝑝𝑎𝑖𝑟 indeed has 𝑣𝑜𝑙𝑢𝑚𝑒.

𝑄's proof verifier in zkAggregatorRollup verifies 𝜋, then the result 𝑣𝑜𝑙𝑢𝑚𝑒, as well as the corresponding query parameters, are stored in zkAggregatorRollup. This state is later included in a state root 𝑆 of zkAggregatorRollup and committed to the chain on which the DEX is deployed.

Now, 𝐴 can retrieve and verify the query result by using a state inclusion proof against 𝑆. This retrieved query result will then be returned back to the DEX's smart contract's handler function. The handler function will be able to match the stored 𝑞𝑢𝑒𝑟𝑦_𝑖𝑑 with the returned query result and adjust the liquidity farming schedule based on the volume data.

zkFabric PoC: Ethereum PoS, Cosmos Tendermint, BNB Chain Light Client ZK Circuits and ZK Bridge
Although on-chain light client solutions are trust-minimized in theory, they are prohibitively expensive to implement in practice. Brevis addresses this challenge by combining light client protocol and ZKP, where zkFabric generates a ZK Consensus Proof for all connected blockchains and stores the corresponding block headers in zkAggregatorRollup. In the initial Proof of Concept of zkFabric, we implement light client protocols in the ZK circuits for Ethereum PoS, Cosmos Tendermint, and BNB Chain.

Light client for Ethereum PoS. The circuit for the Ethereum PoS light client mainly consists of 2 sub-circuits. One is the SSZ Sync Committee Commitment circuit that updates the SSZ commitment for the 512 current validators in the sync committee, which rotates every 27 hours. The other is the aggregate BLS12-381 signature verification for the 512 validators, which mainly conducts hash-to-curve calculations and BLS12-381 pairing over the scalar field of BN254 so that it can be efficiently verified in Ethereum smart contracts. Here, the non-native pairing requires a massive non-native field of arithmetics. Following various tricks for BLS pairing implementations and using the efficient range check gadgets provided by gnark, we are able to achieve the accelerated BLS12-381 signature verification over BN254 scalar field when compared to existing implementations. For the SSZ Sync Committee Commitment circuit, we are working on the optimizations using lookup tables and will release an optimized circuit soon.
Light client for Cosmos Tendermint and BNB Chain. The BNB chain adopts a two-layer architecture, comprising the base layer, referred to as the BNB Beacon Chain (BBC), and the execution layer, called the BNB Smart Chain (BSC). The BBC utilizes Tendermint consensus, while the BSC employs a Proof-of-Authority (PoA) consensus called Parli. Each BSC block is signed off by one of the validators in the set. As a specialized Tendermint application, the BBC manages the election and updates of the BSC validator set. Every 24 hours, a new set of BSC validators are elected and synchronized to the BSC via an IBC-like cross-chain mechanism that predates the official IBC specification. For the BBC (essentially Tendermint), the light client mainly involves verifying a batch of Ed25519 signatures, which are expensive to verify directly on-chain. We implement the non-native Ed25519 signature verifications over the BN254 scalar field in gnark. Using the range check gadgets in gnark, we achieve state-of-the-art performance for non-native Ed25519 signature verification. For BSC, the PoA consensus involves secp256k1 signature verifications which are verified directly in the smart contract due to the existence of pre-compiles.
The aforementioned circuits are implemented in gnark and open-source. Their benchmark performance is shown in Table 1 at the beginning of this blog. Note that we are continuously optimizing the circuit and also expect to utilize hardware acceleration and parallelization in the near future.
Additionally, Nearly all existing interoperability solutions fall into the “external validation model" which necessitates trust in an intermediary entity. As a first step, we built a proof-of-concept demo for a ZK Bridge between the Goerli testnet and the BNB Chain Testnet demonstrating the capabilities of Brevis. Built upon the light clients, we built a bi-directional asset ZK bridge between the Goerli testnet and the BNB Chain Testnet. It should be noted that for the Goerli-to-BNB direction, the expected bridge delay is about 25 minutes since the block header that includes the source chain tx is only considered finalized and relayed after 2-3 epochs (64-96 blocks).
Numerous Exciting Use Cases Enabled by Brevis
Aside from the above example of a ZK Bridge, Brevis empowers developers to create dApps that can access omnichain data across arbitrary time horizons in a way that was previously impossible. This innovation will undoubtedly establish a new paradigm, transforming how dApps are developed across all sectors. In this section, we will present several immediate applications, however we anticipate the community will discover many more use cases.

Data-driven DeFi
In addition to the liquidity farming reward auto-adjustment example discussed previously, we believe data-driven DeFi will become a broad class of applications leveraging Brevis, thanks to the scalability and privacy it enables.

With trust-free access to comprehensive historical and omnichain trading flows, derivatives such as options can now incorporate novel exercise conditions, like Exponential Time Weighted Price or Time-Volume Weighted Price. Alternative derivatives tracking user behavior, price trends, protocol or blockchain TVL changes, volatility, price correlations, and more will also be possible through various implementations of ZQEs.

On-chain active fund management solutions can generate ZK proofs demonstrating that position adjustments are based solely on specific algorithmic models derived from market data, without any unauthorized human intervention. Furthermore, due to the privacy-preserving property of Brevis, the precise model parameters can remain concealed to maintain a competitive market advantage.

User Acquisition with Trust-Free Revenue Sharing
In Web 2.0, the user acquisition process ends when a user downloads or registers, with advertisers paying a fixed price for all users, regardless of their Lifetime Value. This arrangement is not ideal for both advertisers and advertising channels, as the former cannot differentiate user value, and the latter cannot share long-term revenue. This issue arises because post-acquisition user data is private and inaccessible to advertising channels.

Web3 can potentially change this model, as most of the user activity data is public. However, current platforms still follow the Web 2.0 paradigm. Brevis revolutionizes this by allowing advertising channels to generate trust–free revenue proofs for acquired users. This will lead to a fundamental shift in Web 3.0 user acquisition, where advertisers pay only for high-value users, and advertising channels are incentivized to optimally match users with advertisers.
zkDID
Brevis is an essential tool for constructing trust-free zkDID solutions, helping prevent Sybil Attacks and facilitating user life cycle management in various use cases. By generating ZK proofs based on hard-to-fake on-chain behaviors, Brevis enables dApp developers to operate in a fully trust-free manner while preventing Sybil Attacks in campaigns or rollouts.

By leveraging query results and data of aggregated user behaviors, a trust-free user life cycle management process can be built, allowing for loyalty systems, VIP trader programs, and LiveOps campaigns in blockchain gaming. Brevis offers several advantages over in-app accounting, such as lower costs, future-proofing, and portability. zkDIDs generated via Brevis are stored in zkAggregatorRollup, making them accessible to different applications.

Account Abstraction
Brevis offers a compelling use case in Account Abstraction (AA) by improving security and usability in blockchain applications. One key benefit is social recovery, which helps regain wallet access even when the main controlling key is lost. Brevis enables smart wallets to implement social recovery based on recent transaction connections rather than a fixed set of external wallets. This approach reduces maintenance overhead and lowers the entry barrier for new users in the blockchain ecosystem.

Brevis also has potential applications in many other areas such as social and NFT gaming. We encourage developers to explore and discover more exciting use cases for Brev





Honey, I Shrunk the Proof: Enabling on-chain verification for RISC Zero & Bonsai

PAUL GAFNI
INSTRUCTIONAL DESIGN ENGINEER
August 8, 2023
Last week, we posted and verified our first proof on Ethereum's Sepolia Testnet! This is a huge step toward empowering builders to harness the power of ZKPs in their app development. We're excited to enable builders to make use of complex logic in on-chain applications, without ballooning gas costs. Being able to post and verify proofs on-chain makes it possible for Ethereum developers to build off-chain scaling solutions with Bonsai today.


‍

If you're building on Ethereum, you should be thinking about using a zk coprocessor to reduce your gas costs. The core idea is that zkVMs create the opportunity to move the complex part of your application logic off-chain. This means you can have contracts that rely on complex application logic without having to pay gas for that application logic.

Cost will vary a bit based on your application, but for this demo, our costs were:

- 29k gas to request a proof
- 279k gas for the callback

In today's prices, that's less than $15 USD to post & verify a proof on-chain!
$15 may sound expensive for posting & verifying a single proof, but keep in mind that a single proof can represent an arbitrarily large computation or an arbitrarily large batch of computations.

Want to prove the validity of a digital signature? $15.

Want to prove the validity of 1 million digital signatures? Also $15.

When you use a zk coprocessor, you can increase the complexity of your app without impacting gas costs.
‍

Q: Wait, what's a zk coprocessor?

A zk coprocessor is a tool for using ZKPs to offloading computation from on-chain to off-chain. ZK coprocessors are the answer for enabling complex application logic for on-chain applications in a way that will actually scale.

‍

Q: How well does this scale?

A: Gas costs for posting and verifying proofs on-chain *do not depend on the complexity of the computation*. Whether your computation takes 1 million steps or 4 billion steps -- whether it represents one transaction of 1 million transactions -- the gas cost for posting and verifying the proof will be the same. There are two ways that costs will vary with the complexity of the application:

- The gas cost to post & verify the proof depends on the size of the journal (i.e., the public outputs that are being proven).

- The computational cost to generate a proof depends on the complexity of the computation.

‍

Q: I thought RISC Zero's proofs were too big for on-chain verification. How is this possible?

Enabling on-chain verification involved two major engineering milestones:

- a STARK-to-SNARK wrapper

- a Solidity verifier


Our STARK-to-SNARK wrapper reduces our proof size from hundreds of kilobytes to hundreds of bytes. The key idea here is to verify our STARK proof inside a Groth16 prover. Then, we can verify the (much smaller) Groth16 proof on-chain.

With this in place, posting proofs on-chain becomes feasible, as does on-chain verification. With our on-chain verifier contract up and running, using Bonsai as a zk coprocessor is now a real thing.

‍

Q: If I'm building an app with Bonsai, is on-chain verification available to me?

As of this writing, Bonsai is set up to return small proofs that can be cheaply verified on-chain. If you're generating proofs using Bonsai, you can easily post & verify these proofs on Sepolia today. Request Bonsai access and check out the Bonsai Quick Start page to start building.

‍

‍Q: Is this ready to use in production?‍

No. Although you can do experiments and proofs of concept with on-chain verification of RISC Zero proofs today, this is not ready for production. In particular, we have not performed a trusted setup ceremony for Groth16 for our SNARK-to-STARK code, and so our use of Groth16 should not yet be considered secure

‍

Q: What’s next?

- We're continuing to optimize the performance of our prover -- check out our datasheet.
- We're working with Nethermind to audit our zkVM.
- We're working with OP Labs to add zk to their stack.
- We're working to stabilize our APIs for the zkVM and Bonsai.

For now, why not start building? You can request access to our remote proving service here, and you can start building using local proving options right now. As always, find us on Discord if you have questions or want to connect.




拆解以太坊 ZK 协处理器 Axiom 技术优势
Mask Network ｜2023-07-20 9:28
ETHShanghai 2023 峰会中，Axiom 创始人 Yi Sun 介绍了以太坊的 ZK 协处理器 Axiom 以及其在数据访问和计算能力方面的重要性。Axiom 通过 Reflection 操作概念实现了数据访问和计算的扩展，通过验证哈希链和维护缓存来实现查询的有效性。Axiom 的应用前景包括高成本应用、更大数据访问、基于历史数据管理协议的应用等。通过 Axiom，智能合约可以获得更广阔的数据和计算能力，进一步推动以太坊应用的发展。
ETHShanghai 2023 峰会中，Axiom 创始人 Yi Sun 介绍了以太坊的 ZK 协处理器 Axiom 以及其在数据访问和计算能力方面的重要性。Axiom 通过 Reflection 操作概念实现了数据访问和计算的扩展，通过验证哈希链和维护缓存来实现查询的有效性。Axiom 的应用前景包括高成本应用、更大数据访问、基于历史数据管理协议的应用等。通过 Axiom，智能合约可以获得更广阔的数据和计算能力，进一步推动以太坊应用的发展。

以下正文为 Yi Sun 演讲内容的中文编译版本，链接为现场视频：https://www.youtube.com/watch?v=qxSQNbf_SXs

首先，我们来了解实际访问以太坊信息的用户旅程。当我们第一次使用以太坊时，实际接收有关链上发生的情况的信息的方式是通过对存档注释的 JSON-RPC 调用。JSON-RPC API 的目的是实际向用户展示有关链上历史的信息。本质上，我们看到的有关区块链的所有信息都是从这些 API 调用中提取出来的，并以一种条目的形式呈现在网站上供用户读取。

现在，随着用户与区块链交互变得更加熟练，我们开始要求对链的视图越来越复杂。 因此，针对不同的用户权衡，正在开发不同类型的存档节点。 于是就有了 Geth、Erigon、Nethermind，现在又增加了 Reth。我们可根据自身需求选择最适合自己的存档节点。

如果用户对单独的 JSON-RPC API 不满意，可以选择一个索引器来应用后处理，同时跟踪交易。对于不同的应用程序，用户可能对从 The Graph 或 Covalent 返回的数据感兴趣。

最近，还出现了一些钱包和其他产品，提供在存档节点之上进行交易模拟的功能。这意味着我们可以在提交交易之前看到虚拟交易的实际结果。总的来说，作为最终用户，我们与以太坊的交互方式越来越复杂，它在我们读取的数据之上使用了更多的计算。

现在，如果我们不是从用户的角度，而是从以太坊上的智能合约的角度来考虑问题。当然，合约也希望能够访问数据并对数据进行计算，但这更具挑战性。事实上，如果我们去 OpenSea 看看 CryptoPunk 的列表，会发现在页面上的所有信息中，只有很小一部分是在链上的智能合约中可以访问的。

事实上，对于 CryptoPunk 的列表，这些信息只是当前的持有者。当然，页面上还有很多其他信息，但与历史转账信息、历史价格和历史持有者相关的所有信息实际上对智能合约是不可访问的，因为它属于过去的历史。这些历史构成了链上信息，但对于智能合约来说，它们不可用，因为我们需要避免强制要求每个完整的以太坊节点在其随机访问中维护此信息以验证交易。

此外，任何区块链开发人员都可以告诉你，在链上运行计算是非常昂贵的，尽管以太坊具有相对高效的虚拟机（VM）操作，并且通过预编译使某些类型的操作更便宜。例如，在 BN254 曲线上的椭圆曲线运算，以太坊提供了价格较为低廉的支持。然而，对于一些特定的应用程序，以太坊虚拟机仍然是一个非常昂贵的运行环境。当设计一个区块链虚拟机时，必须选择一组固有的操作，这些操作需要仔细计量，以确保每个节点都能以一致的时间验证交易。此外，还必须考虑最坏情况下的安全性和共识稳定性。因此，这里的挑战在于如何实现针对链上应用程序的应用特定扩展。Axiom 旨在为智能合约扩展数据访问和计算能力，满足不同应用的拓展需求。

拆解以太坊 ZK 协处理器 Axiom 技术优势

Axiom 正在构建的是称之为以太坊协处理器（ZK Coprocessor），通过以上操作允许某些智能合约无需信任地委托给我们的离线系统，以便它们可以将数据读取和可验证计算委托给 Axiom。要向 Axiom 发出查询，智能合约可以向我们的链上系统发送一笔交易。我们的离线节点将接收该交易，并根据以太坊的历史查询生成结果，并附上一个零知识证明，以证明结果的正确性。最后，我们再链上验证结果，并可信地将结果交付给下游的智能合约。

这种方式类似于计算机中的 CPU 将计算任务委托给 GPU，并在结果可知后将其取回。这个概念在早期被称为协处理器（Coprocesso）。在幻灯片上，我展示了上世纪 90 年代初的一个高级数学 Coprocesso 的图像与 Axiom 所做的类比。

拆解以太坊 ZK 协处理器 Axiom 技术优势

我们可以深入地了解 Axiom 可以进行哪些类型的操作每个对 Axiom 的查询可以分为三个部分。

首先是读取部分，也是 Axiom 查询的输入方式——我们可以可信地读取历史上链的数据。

第二部分是我们可以在这些数据上运行验证计算。这可能从基本的分析开始，比如对一些数字求和、求最大值或最小值，到更复杂的计算。比如来自密码学的一些签名聚合或验证，甚至可以进行基于零知识的机器学习，比如在链上社交数据上验证某些声誉算法的运行或在金融应用中使用某些机器学习算法。最终，我们将通过虚拟机提供可编程的计算复合功能。

最后一个部分，在读取和计算步骤完成后，我们得到一个结果，并且始终将该结果与零知识证明配对，以证明结果的计算是有效的。因此，我们在以太坊智能合约中验证该证明，然后将结果存储供合约使用。

由于 Axiom 返回的所有结果实际上都经过零知识证明验证，这意味着 Axiom 返回的所有内容的安全性与以太坊本身的安全性在密码学上是等效的。Axiom 的理念是，我们不希望对用户施加任何超出其使用以太坊所已有的密码学假设的额外假设。

接下来我将详细介绍它的实现原理，这涉及到在演讲标题中提到的 Reflection 操作概念。实现这一切的核心原则是，每个区块链上的区块都包含了完整的历史记录。我们可以从当前的以太坊区块开始，向前回溯到我们感兴趣的早期区块。通过获取过去区块和当前区块之间的所有区块头，并通过验证这些区块头的哈希链，我们实际上可以将过去区块的承诺逆向追溯到当前区块。

那 Reflection 有什么好处呢？

我们可以取当前以太坊的一个块，并回溯到我们感兴趣的以前的一个块。如果我们取得过去块和当前块之间的块头，我们可以通过验证这些块头之间的哈希路径，将过去块的承诺反向到当前块中。然后，如果我们对过去块中的某些信息感兴趣，我们可以在该块的承诺中给出一个包含证明。具体来说，这可以是一个 Merkle Patricia Trie 证明，证明该信息存在于该块的状态 trie、交易 trie 或收据 trie 中。至少原则上，在 EVM 中，仅通过对最近块哈希的了解，就可以访问链上的任何过去信息。

遗憾的是，在 EVM 中进行这样操作的代价是昂贵的。正如刚刚提到的，你必须验证所有块头的哈希链和 Merkle 证明，这涉及对大量数据进行许多 Keccak 哈希计算。所以一旦你回溯到过去，就会变得非常困难。因此，我们通过在 EVM 中使用 ZK 封装这个证明来应用 Reflection 操作。因此，我们不需要将所有过去的块头和所有这些 Merkle 证明放在链上，然后进行验证，而是在零知识中检查是否存在一系列过去的块头和一些验证的证明。

这有两个优点。首先，它使我们不必将证明数据放入调用数据中。其次，它让我们能够将证明聚合，而如果没有使用 ZK 的话，这是不可想象的。这里的想法是，在以太坊上验证任意数量的计算时，Gas 成本是固定的，因此我们可以使用单个 ZK 证明来验证大量的历史数据访问。

让我简单谈谈基于 ZK 的 Reflection 操作概念的权衡。

访问数据有两种方式。第一种是你之前所了解的方式——你可以直接从智能合约中访问以太坊上的数据。这有一个非常大的优点，即访问是同步的。因此，你可以直接调用智能合约中的读取函数，获取当前值。例如，当你在 Uniswap 上进行交易时，你就需要这种同步性。然而，它也有很多限制。你的计算能力受到燃料成本的限制，而且无法访问任何历史数据。

第二种，如果你想利用 ZK 的能力来反映到以太坊中，因为你必须生成证明，证明你的访问是正确的，那么就无法以同步方式做到这一点。因此，实际上无法直接访问当前的链上状态，因为你必须针对一个状态进行证明。

另一方面，如果你允许自己以异步方式访问历史数据，那么你可以对其应用几乎无限的计算，并且可以访问大量数据。因此，通过放宽同步的概念，基于 ZK 的 Reflection 操作式数据访问可以大幅扩展。

我们接着了解如何通过 Axiom 实现 Reflection 操作。

首先，我们实际上必须在我们的智能合约中维护所有先前块的缓存。在 EVM 中，最后 256 个块哈希是原生可用的。我们可以证明，在每 1024 个块的批次中，前一个批次的最后一个块的哈希会在下一个块中提交。同样，前一个批次中倒数第二个块的哈希会在最后一个块中提交，以此类推。因此，我们可以反向验证这个哈希链，并通过零知识证明这个哈希链的有效性。

这使我们能够从最近的块开始，一直缓存到创世块的块哈希。实际上，我们在我们的主网智能合约中已经实现了这一点，它包含了从创世块开始的每1024个块哈希的缓存 Merkle 路径。

我们正在添加的另一个功能是 Merkle Mountain Range。它建立在这个块哈希缓存之上，是一种数据结构，使我们能够在有限的 DNA 中引用以太坊中的每个块哈希。

一旦我们建立了缓存，我们可以通过对缓存中的块进行验证来查询 Axiom。为了实现这一点，我们必须证明我们试图访问的以太坊历史数据中的每个数据实际上都承诺在某个块的缓存中。其次，我们必须证明我们在此查询上执行的所有计算都是正确的。为了在链上进行检查，我们会验证零知识证明的有效性。我们还会检查它是否与我们在链上记录的信息相关。我们始终将信任建立在我们的缓存或块缓存中，并将这些块缓存中的信息与零知识证明中的公共信息进行匹配。

现在我们来谈谈 Reflection 操作设想中的可能应用。

水平轴表示数据复杂度，即实际上需要访问多少数据才能实现该应用程序。垂直轴表示计算复杂度，即为完成此任务实际上需要应用多少计算资源。

拆解以太坊 ZK 协处理器 Axiom 技术优势

因此，第一类应用是 Axiom 或任何类型的 Reflection 操作机制可以在以太坊上实现的，但成本稍高的应用。

其中一些例子包括从以太坊共识层的区块头中读取共识级随机数，验证历史账户年龄，或从历史价格信息中读取不同类型的预言机数据。在 EVM 中，可以采用各种解决方案来实现这些应用，但通过将这些解决方案置于零知识中，可以提高效率。

现在，还有另一类应用，大致上需要更多的数据访问，因此需要更多的计算。在我看来，如果不使用 ZK 协处理器，这些应用是无法实现的。

举个例子，一个有趣的应用是允许以太坊上的 Roll-up 以一种可信的方式读取基础层或另一个 Roll-up 的状态，使用零知识进行交互。其中一种应用可能是允许 Roll-up 读取 ERC20 代币的完整余额快照。

如果我们将目光从存储转向账户的交易历史，你可以想象通过记录以太坊地址的完整历史，构建一个可信的声誉、身份或信用评分系统。这可能用于信用评分，或者用于让你访问某种类型的链上 DAO，或者用于让你获得自定义 NFT 的发行权限。

还有一类应用程序是使用链上的历史数据来实际管理协议。一般称为协议记账。

这里的想法是，协议的存在是为了协调参与者的行为，而协调的基本原则是能够对参与者的行为进行奖励或惩罚。如果你观察以太坊上的许多协议，参与者的行动记录实际上完全保存在链上。因此，使用 Axiom，我们可以想象根据协议参与者的完整行动集合，协议可以确定支付结构，甚至对参与者进行某种类型的惩罚，我们认为这可以真正扩展协议应用的设计空间。

最后，如果我们真正提升计算的层次，我们认为使用机器学习模型来调整链上的参数可能会非常有趣。如果你思考传统金融应用，基于大量历史数据进行复杂的未来参数建模是非常常见的，例如价格数据、经济数据等。而当我们看当前的 DeFi，还远远没有达到那个层次。我并不认为 DeFi 应该与传统金融工作方式完全相同，但我们确实认为注入一些历史数据库和基于机器学习的模型和信息可能有助于创建更具动态性的 DeF i协议。

这些只是关于 Reflection 操作可以为区块链带来的一些想法。



Blockchain Capital：我们为何要领投ZK基础设施公司RISC Zero的4000万美元融资？
Bart Stephens、Ryan Sproule、Yuan Han Li2023-07-20热度: 8656

ZK 大规模采用的另一个巨大障碍是 ZK 系统固有的高度复杂的数学和密码学。

Copy code

原文作者：Bart Stephens、Ryan Sproule、Yuan Han Li原文标题：Democratizing Zero-Knowledge Computing: The Power of RISC Zero’s Bonsai Network原文来源：zephyrnet编译：Zen，PANews
7月19日，旨在帮助开发者开发零证明软件的基础设施公司 RISC Zero 宣布完成了 4000 万美元 A 轮融资，Blockchain Capital 领投，参投方包括 Galaxy Digital、IOSG等。作为领投方，Blockchain Capital撰文分析了零知识计算的发展、RISC Zero的特点及优势，PANews对其进行了编译。

想象一下这样一个世界:数据隐私、安全和信任不再受到关注，软件供应链透明且可验证，新一代应用程序可以利用零知识计算的力量来解决数字时代一些最紧迫的挑战。这是零知识 (ZK) 计算的承诺，也是我们投资RISC Zero的原因，这是一家开创性的公司，旨在通过其 Bonsai 网络实现 ZK 访问的民主化。

零知识计算是一种革命性的原语，它允许应用程序和协议利用简洁性、正确性和零知识这三个关键属性。这意味着，通过验证 ZK 证明（正确性），验证者可以通过近乎精确地保证知道计算已正确执行。

此外，经过验证的证明将比原始计算简洁得多，并且还可以利用证明的零知识属性来确保验证者对计算本身一无所知。这种独特的属性组合具有深远的影响，并提供了一种验证信息的新方法。这些属性共同平衡了隐私、安全和信任的需求，为更安全、更私密的数字世界提供了潜力。但在 ZK 充分发挥其潜力之前，仍存在一些障碍。

首先，在 ZK 中运行计算耗时太长且成本太高。证明时间和成本需要大幅下降，才能在ZK中实现复杂的计算。好消息是这些正在急剧下降：ZK 证明时间和成本的轨迹一直遵循技术史上熟悉的趋势 - 无论是摩尔定律（计算成本每两年减半）、弗拉特利定律（人类基因组测序成本以更显着的速度下降）还是克莱德定律（磁盘密度大约每 13 个月增加一倍）。证明系统（Plonky2、Hyperplonk、STARK）的最新架构进步以及底层密码学（Poseidon）的进步降低了创建任何计算的 ZK 证明所需的开销。而这些领域的进步将继续以类似的速度发生(特别是最近人才涌入ZK)，证明管理费用也将受益于硬件加速(MSM, NTT)的进步，这是迄今为止尚未得到充分开发的东西。

ZK 大规模采用的另一个巨大障碍是 ZK 系统固有的高度复杂的数学和密码学。推动ZK创新所需的深度和专业知识水平只有一小部分高技能的技术开发人员能够胜任。

理想情况下，开发人员可以自由地用自己喜欢的语言编写程序，同时仍然能够以零知识证明计算，而无需使用低级、ZK 特定的编程语言去手写输入和设计电路。这就是 RISC Zero 的 Bonsai 平台成为全球开发者游戏规则改变者的地方，也是我们投资 RISC Zero 的原因。

通过创建模拟 RISC-V 指令集架构 (ISA) 的零知识虚拟机 (zkVM)，RISC Zero 构建了一个能够证明低级代码执行的系统。由于 ISA 是人类可读代码和机器可解释指令之间的桥梁，这一成就意味着Bonsai网络可以证明任何高级程序都可以被编译成这种体系结构。由于大多数现代编程语言都与 RISC-V 兼容，RISC Zero 的 Bonsai 能够以零知识执行几乎任何任意计算机程序。

在零知识（ZK）计算变得普遍的未来，许多以前不可能的应用程序将成为可能。这不仅包括基于以太坊的应用程序，利用RISC Zero的盆景网络作为协处理器(在验证链上结果之前执行资源密集型的链下工作)，还将扩展到加密货币以外的应用程序。例如，Bonsai可以让白帽黑客在不直接披露漏洞的情况下证明安全漏洞和错误的存在。它还可以通过允许用户下载和验证ZK证明来确保他们运行的代码在Bonsai中预先审计，从而防止未来对软件的供应链攻击。最令人兴奋的是，Bonsai的广泛采用可能会带来尚未想象到的全新用例。

除了令人印象深刻的技术突破之外，RISC Zero背后还有着强大而独特的团队。三位联合创始人Brian Retford、Jeremy Bruestle和Frank Laub已彼此相识 20 多年。他们共有的经历包括共同创建多家公司，其中最近的一家公司涉足人工智能优化和编译领域，最终被英特尔收购。

三人组的每位成员都为 RISC Zero 带来了丰富的经验：Brian 曾在 Google Cloud Platform 从事定价和计量系统工作；Jeremy 是一位终生的数学爱好者，致力于基因测序的 GPU 加速，并拥有密码学、高性能计算（HPC） 和安全方面的背景；Frank 在编译器方面拥有深厚的背景，并构建了众多代码库。凭借共同的历史和多样化的技能，RISC Zero团队具有独特的优势，他们向大众提供零知识计算，并有可能在此过程中重塑数字格局。

当我们展望零知识计算广泛普及的未来时，创新的可能性是无限的。RISC Zero 的 Bonsai 网络能够支持广泛的编程语言，将使 ZK 计算民主化，并使开发人员能够在各个领域创建安全、私有和无需信任的应用程序。从加强网络安全措施到增强对软件供应链的信任，再到大幅提高链上应用程序可用的计算能力，零知识计算的潜在影响是巨大的。快速下降的 ZK 证明时间和成本、RISC Zero 的忠诚团队以及 Bonsai 作为多功能计算平台的出现，预示着计算的新时代——隐私、安全和信任被构建到我们数字世界的结构中。