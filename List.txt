A Guide to ZK Coprocessors for Scalability

KAYLEI ATCHLEY
GUEST WRITER
October 19, 2023
If youâ€™re operating an on-chain application, a ZK Coprocessor is a key tool for allowing you to scale your on-chain logic while keeping gas costs low. In this post, we review what a coprocessor is, why it matters, and how you can use the Bonsai ZK coprocessor architecture to scale your application.

â€

Computational Limitations of On-chain Applications
Having your application execute entirely on the EVM comes with drawbacks. Tasks requiring heavy computation or large stores of data require gas fees so high that using your application can quickly become cost prohibitive. This means certain features are not realistically possible on the EVM, limiting the potential of your applications.

The trick is to move computation off-chain, drastically reducing gas fees and making your application more attractive to users. Traditionally, this would require trusting the computation executed on a centralized server, sacrificing the verifiable ecosystem of Ethereum in the name of cost savings. Fortunately, ZK proofs provide a way to securely verify these off-chain results while maintaining core values of decentralization, and at a fraction of on-chain costs.

â€

Entering the Chat: Bonsai ZK Coprocessor
The Bonsai ZK Coprocessor Architecture extends the capabilities of on-chain applications with programmable & verifiable off-chain computation. Instead of spinning up your own ZK infrastructure, you can upload the program and request that Bonsai generate proofs on demand.


The Bonsai ZK Coprocessor Architecture is powered by connecting our zkVM and Bonsai with Ethereum using our ETH Relay. This enables us to extend the functionality of Ethereum smart contracts by allowing applications to port logic into Rust and execute the logic off-chain on Bonsai.


One important callout is that Bonsai isnâ€™t restricted to Ethereum. Any blockchain that possesses an execution and consensus layer can harness the Bonsai coprocessor to shift execution or computation off-chain.

A few examples include:

Optimistic Layer 2, such as Optimism and Arbitrum
ZK Layer 2, like Starkware and ZKSync
EVM Layer 1, including Avalanche and Polygon
Non-EVM Layer 1, encompassing Solana and Aptos
Cosmos interchains
â€

What is a Coprocessor?
A coprocessor serves as a companion to a processor, allowing for off-loading computation in a resource-constrained system. For example, running an AI model like ChatGPT on your cell phone would be unfeasible. Your phone is slow, has limited storage, youâ€™re paying to download the massive model, and your battery life is limited. However, when you ask ChatGPT a question, itâ€™s sent to a dedicated server where it can run cheaply and efficiently then send back an answer. In this way, ChatGPTâ€™s servers are acting as an AI co-processor for your cell phoneâ€™s limited resources.


On the other hand, the EVM serves as a versatile platform capable of executing various operations. Analogous to a personal device, the EVM can handle diverse tasks but might not always be the most efficient for high-volume operations. And zkVM, much like a cloud computer or mainframe, is designed for general-purpose tasks but excels in speed and cost-effectiveness.

â€

Bonsai ZK Coprocessorâ€™s Architecture

Call Bonsai, specifying which program and inputs to execute. You can call Bonsai in one of two ways:
- Call Bonsai from Ethereum: call the BonsaiRelay contract from your smart contract.
- Call Bonsai from off-chain: call Bonsai using the REST API.
Bonsai executes your program off-chain on the zkVM with the inputs you provided.
Bonsai sends a proof of the executed program back to BonsaiRelay.
The proof is checked by an on-chain verifier.
Your contract receives the verified result.
Bonsai massively reduces gas fees and expands the capabilities of on-chain applications â€” slicing through price barriers for your users while providing developers with wider opportunities. This architecture allows you to move the expensive parts of you application, even the entire logic, out of your Solidity smart contracts and into a Rust program that executes off-chain.

â€

Use cases for ZK coprocessors
Many applications, such as on-chain gaming or central limit order books, need off-chain computation to be economical. However, any application logic requiring more than 250K gas can potentially reduce costs with ZK coprocessors.

DAOs are a perfect example of collective on-chain activity involving many actors and multiple smart contracts and leading to heavy computation. ZK Coprocessors for DAO governance ensure off-chain compute for cheaper gas, and verification of on-chain data among parties. With the Bonsai DAO Governor, DAO members were able to lower their gas fees by more than 50% (from $6-9, to just $2-3 per vote during July 23rd) by moving compute off-chain. Weâ€™ll release more on how we built the Bonsai Governor soon!

Another notable use-case includes Web2 to Web3 verification. For example, Bonfire Wallet allows users to create a burner wallet using WebAuthn, while Bonsai ZK Coprocessor handles off-chain compute.


â€

Build with Bonsai
To use Bonsai as a coprocessor for Ethereum, all you need to do is:

Write a zkVM application that handles your app logic
Write a Solidity contract that asks Bonsai to run your zkVM app and what to do with the results
Then, follow the instructions in the deployment guide.

Bonsai can help whether you're looking to take heavy computations off-chain or need to generate proofs for your trustless, verifiable software. For any questions, reach out to our team on Discord!


ç”±äºåŒºå—é“¾ä¸ºäº†ä¿æŠ¤å®‰å…¨ï¼Œè€Œæ–½åŠ äº†è®¡ç®—é™åˆ¶ï¼ŒZKåå¤„ç†å™¨(Coprocessors)æ­£é€æ¸æˆä¸ºä¸€ä¸ªå¤‡å—å…³æ³¨çš„è¯é¢˜ã€‚å®ƒèƒ½å¤Ÿå¢å¼ºè®¡ç®—èƒ½åŠ›ï¼ŒåŒæ—¶ä¿æŒå¼ºå¤§çš„å®‰å…¨æ€§ã€‚åœ¨æœ¬æ–‡ä¸­ï¼ŒGalaxy Digital ç ”ç©¶å‘˜ E å°†æ¢è®¨ZKåå¤„ç†å™¨çš„æ¦‚å¿µã€ä½œç”¨ä»¥åŠæ­£åœ¨æ„å»ºçš„ä¸€äº›é¡¹ç›®ã€‚

ä¸€èˆ¬æ¥è¯´ï¼Œåå¤„ç†å™¨æ˜¯ä¸€ç§ä¸“é—¨çš„ç»„ä»¶ï¼Œå®ƒååŠ©CPUï¼Œé€šè¿‡æ›´ç†Ÿç»ƒåœ°å¤„ç†æŸäº›ä»»åŠ¡æ¥æé«˜è®¡ç®—æœºç³»ç»Ÿçš„æ•´ä½“æ•ˆç‡å’Œé€Ÿåº¦ã€‚

ZKåå¤„ç†å™¨æ˜¯ä¸€ä¸ªäº’æ“ä½œå±‚ï¼Œå®ƒæ‰§è¡Œä»»æ„è®¡ç®—å¹¶æä¾›ä¸€ä¸ªâ€œæ”¶æ®â€ï¼Œè¿™æ˜¯ç¡®è®¤è®¡ç®—æ­£ç¡®æ‰§è¡Œçš„æ•°å­¦æœ‰æ•ˆè¯æ˜ã€‚

æ¯ä¸ªæ”¶æ®éƒ½åŒ…æ‹¬ä¸€ä¸ªåŠ å¯†æ ‡è¯†ç¬¦ï¼Œè¡¨ç¤ºæ‰§è¡Œäº†å“ªä¸ªè®¡ç®—ï¼Œå¹¶è®°å½•è®¡ç®—çš„ä»»ä½•å…¬å…±è¾“å‡ºã€‚

æœ‰äº†è¿™äº›æ”¶æ®ï¼Œæœºå™¨å¯ä»¥æ˜ç¡®åœ°â€œè¯æ˜â€è®¡ç®—å‘ç”Ÿäº†ã€‚è¿™ä¸ä»…ä»…æ˜¯è¯´æ˜è®¡ç®—å‘ç”Ÿäº†ï¼Œè¿˜æä¾›äº†ä¸€ä¸ªå¯éªŒè¯çš„è½¨è¿¹ã€‚è¿™å°±åƒä¸€ä¸ªæ— éœ€ä¿¡ä»»çš„ã€å®‰å…¨çš„è®¡ç®—å®¡è®¡ï¼

ä¸ºä»€ä¹ˆæˆ‘ä»¬éœ€è¦ZKåå¤„ç†å™¨ï¼Ÿ

åŒºå—é“¾å¯¹è®¡ç®—èƒ½åŠ›æ–½åŠ äº†é™åˆ¶ï¼Œå°†L1/L2ä¸Šçš„æ“ä½œé™åˆ¶åœ¨ä¸€å°éƒ¨åˆ†å›ºæœ‰å®‰å…¨æ“ä½œä¸­ä»¥ç¡®ä¿å®‰å…¨ã€‚ZKåå¤„ç†å™¨å¢å¼ºäº†è®¡ç®—èƒ½åŠ›ï¼Œä½¿å¾—åœ¨ä¿æŒå¼ºå¤§å®‰å…¨æ€§çš„åŒæ—¶èƒ½å¤Ÿæ‰§è¡Œæ›´å¹¿æ³›çš„æ“ä½œã€‚

æ­£åœ¨æ„å»ºçš„zkåå¤„ç†å™¨çš„åè®®æœ‰å“ªäº›ï¼Ÿ

Axiom æ˜¯ä»¥å¤ªåŠçš„ ZK åå¤„ç†å™¨ï¼Œå®ƒä¸ºæ™ºèƒ½åˆçº¦æä¾›äº†å¯¹æ‰€æœ‰é“¾ä¸Šæ•°æ®çš„æ— éœ€ä¿¡ä»»çš„è®¿é—®ä»¥åŠå¯¹å…¶è¿›è¡Œä»»æ„è¡¨è¾¾å¼è®¡ç®—çš„èƒ½åŠ›ã€‚

Axiomå¯¹äºä»»ä½•åè®®æˆ–å»ä¸­å¿ƒåŒ–åº”ç”¨ï¼ˆdappï¼‰éƒ½æœ‰ç”¨ï¼Œåªè¦å…¶ä¸­æ¶‰åŠå†å²é“¾ä¸Šæ•°æ®æˆ–è¡¨è¾¾å¼è®¡ç®—ï¼ŒåŒ…æ‹¬æ— éœ€ä¿¡ä»»çš„ä¼šè®¡ã€åŠ¨æ€DeFiã€æ— éœ€ä¿¡ä»»çš„é“¾ä¸‹æ²»ç†ä»¥åŠæ— éœ€ä¿¡ä»»çš„é“¾ä¸Šé¢„è¨€æœºç­‰ã€‚

Axiomçš„ä½¿å‘½æ˜¯ä½¿é›¶çŸ¥è¯†è¯æ˜çš„åŠŸèƒ½åœ¨é“¾ä¸Šåº”ç”¨ä¸­å°½å¯èƒ½åœ°æ˜“äºè®¿é—®å’Œä½¿ç”¨ï¼Œä»è€Œè§£é”ä¸€æ³¢æ›´ä¸°å¯Œã€æ›´å…·è¡¨ç°åŠ›çš„ä¿¡ä»»æœ€å°åŒ–å»ä¸­å¿ƒåŒ–åº”ç”¨çš„æ–°æµªæ½®ã€‚

Tanuki åˆ©ç”¨Axiomä¸ºåŸºäºå†å²é“¾ä¸Šæ•°æ®çš„é’±åŒ…è¯„åˆ†è®¡ç®—æä¾›äº†ä¸€ä¸ªæ— éœ€ä¿¡ä»»ã€é€æ˜çš„ç³»ç»Ÿã€‚è¿™äº›æ•°æ®å¯ä»¥ç”¨äºä¿¡ç”¨è¯„åˆ†åè®®ï¼Œå¦‚Karma3labsï¼ŒNFTå®šä»·åˆ†æï¼Œå¦‚SPICYESTç­‰ã€‚

Tanuki çš„è§£å†³æ–¹æ¡ˆæ˜¯ä¸€ç§å»ä¸­å¿ƒåŒ–çš„æ›¿ä»£æ–¹æ¡ˆï¼Œä½¿åè®®èƒ½å¤Ÿä»¥æ— éœ€ä¿¡ä»»çš„æ–¹å¼è®¡ç®—ç›¸å…³æŒ‡æ ‡ï¼Œä»è€Œä¿ƒè¿›å…¬å¹³å’Œé€æ˜çš„äº’åŠ¨ã€‚ä¼ ç»Ÿä¸Šï¼Œè¿™äº›è®¡ç®—åªèƒ½åœ¨ä¸­å¿ƒåŒ–ä¸”ä¸å¤ªé€æ˜çš„ç³»ç»Ÿä¸­è¿›è¡Œã€‚

Risc Zeroæä¾›äº†ä¸€ä¸ªå¯ä»¥åœ¨ä»»ä½•å¹³å°ä¸Šè¿è¡Œçš„zkVMã€‚å®ƒæ˜¯ä¸€ä¸ªè™šæ‹Ÿå¾®æ§åˆ¶å™¨/åå¤„ç†å™¨ï¼Œä¸ºå…¶è¿è¡Œçš„æ¯ä¸ªç¨‹åºç”Ÿæˆæ”¶æ®ï¼Œæœ‰ç‚¹åƒä¸€ä¸ªå®‰å…¨çš„è™šæ‹ŸAdruinoã€‚

RiscZeroçš„Bonsaiæ˜¯ä¸€ä¸ªé€šç”¨çš„é›¶çŸ¥è¯†è¯æ˜ç½‘ç»œã€‚å®ƒæä¾›äº†ä¸ºåŒºå—é“¾æ™ºèƒ½åˆçº¦æ‰§è¡Œé“¾ä¸‹è®¡ç®—çš„èƒ½åŠ›ã€‚

Herodotus æ—¨åœ¨ä¸ºæ™ºèƒ½åˆçº¦æä¾›æ¥è‡ªå…¶ä»–ä»¥å¤ªåŠå±‚çš„åŒæ­¥é“¾ä¸Šæ•°æ®è®¿é—®ã€‚ä»–ä»¬è®¤ä¸ºå­˜å‚¨è¯æ˜å¯ä»¥ç»Ÿä¸€å¤šä¸ªRollupsçš„çŠ¶æ€ï¼Œç”šè‡³å…è®¸ä»¥å¤ªåŠå±‚ä¹‹é—´çš„åŒæ­¥è¯»å–ã€‚

Poseidon ZKP æ—¨åœ¨å¡«è¡¥åˆ›å»ºEVMåŸç”ŸzkDAppsçš„ç©ºç™½ã€‚å®ƒé’ˆå¯¹ä»¥éšç§ä¸ºä¸­å¿ƒçš„zkDAppså¼€å‘çš„ä¸¤ä¸ªä¸»è¦éšœç¢ï¼šç”±äºåŠ å¯†å¤æ‚æ€§è€Œä½¿ä½¿ç”¨ZKPçš„é«˜é—¨æ§›ï¼Œä»¥åŠæ˜‚è´µçš„é“¾ä¸ŠéªŒè¯ã€‚

Poseidon ZKP æ­£åœ¨å¼€å‘çš„ä¸€ä¸ªåŠŸèƒ½æ¶‰åŠå°†å¯ç»„åˆçš„ZKPåŸè¯­ä½œä¸ºæ™ºèƒ½åˆçº¦åˆ›å»ºã€‚åœ¨æ­¤åŸºç¡€ä¸Šï¼Œä»–ä»¬æä¾›äº†ä¸€ä¸ªZK-ZKèšåˆå™¨ï¼Œå°†ä¸€æ‰¹å®¢æˆ·ç«¯ç”Ÿæˆçš„è¯æ˜ï¼Œå¹¶åˆå¹¶ä¸ºä¸€ä¸ªè¯æ˜ï¼Œæ˜¾è‘—é™ä½äº†æ‘Šé”€åçš„ZKPéªŒè¯æˆæœ¬ã€‚

å¦ä¸€ä¸ªç”±Devloperå…±åŒåˆ›ç«‹ä¸”ä½è°ƒçš„é¡¹ç›®Plutoï¼Œæ­£åœ¨æ¢ç´¢å¦‚ä½•ä¸ºç‰¹å®šäºdAppçš„å¯æ‰©å±•æ€§åˆ›å»ºæ— ç¼çš„å¼€å‘è€…ä½“éªŒã€‚

å‡†å¤‡å¥½è®©æ‚¨çš„dAppsåœ¨æ•ˆç‡å’Œå®‰å…¨æ€§æ–¹é¢è¾¾åˆ°æ–°çš„é«˜åº¦å—ï¼Ÿæ‹¥æŠ±zkåå¤„ç†å™¨çš„æœªæ¥ï¼Œå¼€å¯æ— å°½çš„å¯èƒ½æ€§ã€‚



Brevis: A Smart ZK Coprocessor for Blockchains
Celer Network
CELR

CelerNetwork
By CelerNetwork

Created 7 months ago, last updated 2 months ago
â€¢
15 mins read
Brevis: A Smart ZK Coprocessor for Blockchains
Table of Contents
TL;DR
Web3 dApps are Missing Out on the Value of Utilizing Omnichain Data
Zero-Knowledge Succinct Proofs: The Magic of Computation Migration
Brevis System Overview
An Example Walkthrough
zkFabric PoC: Ethereum PoS, Cosmos Tendermint, BNB Chain Light Client ZK Circuits and ZK Bridge
Numerous Exciting Use Cases Enabled by Brevis
Data-driven DeFi
User Acquisition with Trust-Free Revenue Sharing
zkDID
Account Abstraction
TL;DR
Web 2.0 applications often operate as walled gardens with limited data interoperability, resulting in user lock-in and fragmented identities. Web3 decentralized applications (dApps) built on top of blockchains have the potential to overcome these issues. However, smart contracts, which are the core of dApps, currently lack a trust-free way to access and utilize the vast amount of data stored in the full history of multiple blockchains. To address this limitation, weâ€™re introducing you to Brevis, a smart Zero-Knowledge (ZK) coprocessor for blockchains that enables dApps to access, compute, and utilize arbitrary data across multiple blockchains in a completely trust-free way.

Brevis's architecture consists of three components: zkFabric, zkQueryNet, and zkAggregatorRollup. zkFabric collects block headers from all of the connected blockchains and generates Consensus Proofs that attest to the validity of these block headers via ZK light client circuits. This is essential for dApps to be able to access the block headers and all of the states from all supported blockchains in a trust-free way. zkQueryNet is an open marketplace of ZK Query Engines that can accept data queries from on-chain smart contracts directly and is able to generate the query results and corresponding ZK Query Proofs via the ZK Query Engine circuits. These engines range from highly specialized, such as calculating the trading volume of a DEX during a specific time period, to highly generalized with data indexing abstractions and high-level query languages, catering to a diverse set of application requirements. zkAggregatorRollup is a specialized ZK rollup that acts as the aggregation and storage layer for zkFabric and zkQueryNet. It verifies the proofs from both of these components, stores the attested data, and commits its zk-attested state roots to all connected blockchains, allowing dApps to access the attested query results directly in their on-chain smart contractsâ€™ business logic.

With this modularized architecture, Brevis enables fully trust-free, flexible and highly efficient data access and computation capabilities across all supported chains for on-chain smart contracts. This enables entirely new paradigms for dApp development. Brevis has a wide range of use cases like data-driven DeFi, zkBridges, on-chain user acquisition, zkDIDs, social account abstraction, and much more.

In the initial Proof of Concept for Brevis, we built some of the fastest ZK light client circuits as parts of zkFabric with gnark for Ethereum PoS, Cosmos, and BNB Chain to enable any EVM and non-EVM chains to access the states of these three chains in a completely trust-free way. Some of the key circuit performance benchmark numbers are summarized in Table 1 (using a Linux Server with 20 cores@2.3GHz and 384GB of memory with no GPU acceleration). Using these ZK light client circuits, we implemented a user-facing asset zkBridge between Ethereum Goeril and BNB Chain Testnet for users to try out.
For a more in-depth description of Brevis, continue reading this blog or you can refer to our Brevis White Paper for more comprehensive and technical details.
Subscribe
Join us in showcasing the cryptocurrency revolution, one newsletter at a time. Subscribe now to get daily news and market updates right to your inbox, along with our millions of other subscribers (thatâ€™s right, millions love us!) â€” what are you waiting for?

Web3 dApps are Missing Out on the Value of Utilizing Omnichain Data
Web 2.0 applications have revolutionized user interaction and content generation on the internet. However, these applications often operate as walled gardens, with user data stored in centralized databases controlled by platform providers. This leads to challenges such as limited data interoperability, fragmented identities, financial and social data lock-ins, and subsequent issues like hindered innovation, vendor lock-in, privacy issues, and fragmented user experiences.

Web3 decentralized applications (dApps) have the potential to break these information silos by being built on top of blockchains, which have append-only and publicly accessible data storage. With the multi-blockchain expansion and adoption of dApps continuing to grow, L1 blockchains and L2 rollups have accumulated a wealth of raw data, such as asset transfers, contract function calls, in-contract events, and blockchain state roots. With all of this data, it makes it possible to extract valuable information such as ownership of assets, user activity profiles, social graphs, financial connections, market pricing trends, trading volumes and much more.

Many off-chain products and projects are already leveraging this unique property of publicly accessible data storage. Products like Dune Analytics and Graph provide off-chain data indexing or data analytics for blockchain applications across time. They can also be used to provide stateful data, such as user transaction history for dApps' frontend UIs. These applications access blockchain data in an off-chain way, recording, indexing, and computing data via the blockchain nodes' RPC endpoints.
Intuitively, on-chain blockchain applications or smart contracts should be able to easily access and utilize these omnichain data insights in their business logic in a completely trust-free way, since all of these dApps are the â€œnative residentsâ€ inside of the blockchains.
However, this is not the case.

In reality, Web3 dApps simply have no way to access the vast majority of the data stored in blockchains in a trust-free way. This is because smart contracts deployed on a single blockchain are living in the context of blockchain virtual machines and can only access data:
via explicitly defined interfaces of other smart contracts;
That is on the same blockchain;
Only in the most current state of the blockchain instead of with a complete historical view.
One might argue that solutions, such as parsing and computing data query semantics directly in smart contracts or validating consensus algorithms with pure smart-contract-based trust-free light clients, are in theory possible. However, these approaches are infeasible due to the high on-chain computation costs. Off-chain Oracle solutions can be used, but they require additional reliance on external Oracle security for data validity.

So, how can we allow smart contracts to access and compute data from any blockchain over an arbitrary period of time?

Zero-Knowledge Succinct Proofs: The Magic of Computation Migration
Zero-knowledge succinct proof technology (ZKP) is an emerging field in cryptography with the potential to transform our digital interactions. It allows one party to prove the validity of a computation to another without revealing any information about the input value. The verifying party only needs to run a computationally inexpensive program, called a verifier, to confirm the computation's accuracy.
ZKP not only offers privacy benefits but also enables the migration of computation from high-cost per unit locations to low-cost per unit locations. The prover performs a computationally expensive operation to complete the computation and generate a cryptographic proof, while the verifier runs a cheaper operation to validate the proof. This process shifts the computation location from verifier to prover, making it a worthwhile tradeoff if the prover's unit computational costs are substantially lower than those of the verifier. This computation migration property is the driving force behind many ZK rollups. We will also leverage this property to design Brevis.

Brevis System Overview
As shown in Figure 1, Brevis's architecture consists of three main components: zkFabric, zkQueryNet, and zkAggregatorRollup. zkFabric collects block headers from all of the connected blockchains and generates ZK Consensus Proofs that attest to the validity of these block headers. These block headers are further zk-verified and stored in zkAggregatorRollup. zkQueryNet accepts data queries from dApps and generates ZK Query Proofs based on the attested block headers stored in zkAggregatorRollup. These query results are also zk-verified and stored in zkAggregatorRollup. Essentially, zkAggregatorRollup is a ZK rollup that acts as the aggregation and storage layer for zkFabric and zkQueryNet. By committing its zk-attested state roots to all Brevis connected blockchains, zkAggregatorRollup allows dApps to access attested query results and utilize them directly in their on-chain smart contract logic in a completely trust-free way.
With this high-level overview in mind, letâ€™s walk through each component.

First, in order to utilize arbitrary data across multiple blockchains, dApps need to have a trust-free way to access the block headers from blockchains other than their native chain. This is because block headers contain state roots that can be used to access the data and states of the blockchains. To fulfill this need, zkFabric is introduced to generate ZK Consensus Proofs for block headers of all the supported chains. A Consensus Proof is generated by a light client circuit proving that the block header in question is generated according to the consensus rule of the corresponding blockchain. zkFabric itself is a decentralized system consisting of a network of block header relayers and provers.
To actually extract valuable information from the zk-attested block headers, zkQueryNet is built as an open marketplace of ZK Query Engines that directly interface with dApp developers and smart contracts. A dApp developer can choose a ZK Query Engine that fits their needs and then write queries via high-level APIs in smart contracts.
At run time, a smart contract can call the Agent Smart Contract of zkQueryNet targeting a specific ZK Query Engine. This query will be picked up by the provers of this ZK Query Engine. Using the already zk-attested block headers provided by zkFabric, the ZK Query Engine can then compute the query results and generate a ZK Query Proof attesting that computation is done correctly.

Different ZK Query Engines can have very different APIs ranging from generalized query languages to highly specific function calls with a fixed number of parameters. For example, on one side of the spectrum, a specific ZK Query Engine may only expose a function that accepts two block numbers and two chain IDs that will return the Time Weighted Average Price for the ETH/USDC pair during a specified time period on Uniswap for the specified two blockchains. On the other hand, a generalized ZK Query Engine can present developers with a blockchain indexing abstraction using high-level database queries such as SQL or GraphQL, which is very much like what they can do in off-chain data solutions such as Dune Analytics and Graph.

Brevis will provide a set of ZK Query Engines that address many immediate use cases with reasonable flexibility and high performance. As zkQueryNet is an open marketplace, we expect dApp developers and other third parties to provide other ZK Query Engines to better serve a diverse ecosystem of applications.

Finally, zkAggregatorRollup is a ZK rollup blockchain powered by a lightweight ZK virtual machine that aggregates different proofs and their inputs from zkQueryNet and zkFabric. Specifically, zkAggregatorRollup VM runtime has the following functionalities:
Recursively verify proofs generated by zkQueryNet and zkFabric;
Store the zk-verified block headers from zkFabric;
Store queries and the zk-verified results.
When plugging in a ZK Query Engine or adding a new type of consensus, zkAggregatorRollup will be extended to support the verification of the corresponding ZK proofs. Moreover, unlike many ZK rollup chains where the proofs of state root progression are only committed to a single blockchain, zkAggregatorRollup's state root proofs are committed to all the blockchains supported by Brevis.
With zkAggregatorRollup's state roots available on all connected chains, smart contracts can access the query results and block headers via data inclusion proofs. The primary benefit of using zkAggregatorRollup as an aggregation point is to reduce the block header communication or verification overhead from O(N^2) to O(N) (where N is the number of blockchains supported by Brevis), and to share query results on-demand and efficiently across all connected blockchains.

To sum up, Brevis has the following key advantages:

Trust-free: Brevis does not rely on any off-chain party to attest data and computation integrity. Instead, it relies solely on ZK succinct proofs. Therefore, applications using Brevis do not need to accept any additional trust assumptions other than those of the underlying blockchains and cryptographic protocols.
Omnichain: Brevis integrates with multiple blockchains running on different consensuses and therefore enables omnichain data access and computation.
Modularized: Brevis uses a highly modularized design in its zkQueryNet and therefore can cater to a wide range of application requirements through different flavors and implementations of ZK Query Engines.
Low-cost: Brevis's zkAggregatorRollup essentially works as a batching and aggregation layer for block headers and query results. Therefore, zkAggregatorRollup significantly reduces the on-chain costs by orders of magnitude by removing the otherwise N-to-N communication overhead and by enabling cross-chain and cross-application query results sharing.
It is important to note that the key difference between Brevis and off-chain data indexing solutions such as Dune Analytics and Graph is that Brevis can generate zk-attested query results that can be directly utilized by the business logic of on-chain smart contracts in a trust-free way. Compared to off-chain solutions whose data results can only be used in the web2-based data analytic context.

An Example Walkthrough

Before we discuss a wide range of application use cases, we present a concrete application example to provide an overview of Brevis. Note that this overview abstracts some key details and we refer readers to the full white paper for more details.

Multi-blockchain decentralized exchanges (DEXes), such as PancakeSwap, often need to dynamically adjust farming rewards for incentivized pools based on trading pair quality scores such as average daily volume, 14-day volume, price volatility, number of active traders, and liquidity providers across all supported blockchains.

Currently, such adjustments must be made through governance proposals, which entail significant human overhead and can only be done when the setting deviates severely from optimal. This causes things to lag behind market trends and often leads to a decline in user engagement, revenue loss, and a waste of treasury funds due to suboptimal reward configurations.

Brevis can address these challenges by enabling DEXes to adjust the liquidity farming schedule programmatically and in a trust-free way based on omnichain market trends. For simplicity, let us assume that volume is all we care about. Letâ€™s also assume that there is a ZK Query Engine ğ‘„ in zkQueryNet that provides a set of highly optimized circuits for DEX volume data with an API that looks like the following:

uint_64 get_trading_volume(uint_64 chain_id,
uint_64 start_block,
uint_64 end_block,
address pair)
Figure 2 shows the step-by-step process of how this use case works. To use this data compute API, the DEX smart contract first needs to make a function call to the Agent Smart Contract (denoted as ğ´) of zkQueryNet with the above query parameters specified. Note that this function is asynchronous and only immediately returns a ğ‘ğ‘¢ğ‘’ğ‘Ÿğ‘¦_ğ‘–ğ‘‘ so the DEX's smart contract needs to remember this ID and has a handler to process the return value later.
This function call is then picked up by ğ‘„'s prover, denoted by ğ‘ƒ_ğ‘. Using the block headers for ğ‘â„ğ‘ğ‘–ğ‘›_ğ‘–ğ‘‘ (which has already been verified and stored in zkAggregatorRollup), ğ‘ƒ_ğ‘ will generate a ZK proof ğœ‹ proving that on ğ‘â„ğ‘ğ‘–ğ‘›_ğ‘–ğ‘‘ during the time period from ğ‘ ğ‘¡ğ‘ğ‘Ÿğ‘¡_ğ‘ğ‘™ğ‘œğ‘ğ‘˜ to ğ‘’ğ‘›ğ‘‘_ğ‘ğ‘™ğ‘œğ‘ğ‘˜ the DEX's ğ‘¡ğ‘Ÿğ‘ğ‘‘ğ‘–ğ‘›ğ‘”_ğ‘ğ‘ğ‘–ğ‘Ÿ indeed has ğ‘£ğ‘œğ‘™ğ‘¢ğ‘šğ‘’.

ğ‘„'s proof verifier in zkAggregatorRollup verifies ğœ‹, then the result ğ‘£ğ‘œğ‘™ğ‘¢ğ‘šğ‘’, as well as the corresponding query parameters, are stored in zkAggregatorRollup. This state is later included in a state root ğ‘† of zkAggregatorRollup and committed to the chain on which the DEX is deployed.

Now, ğ´ can retrieve and verify the query result by using a state inclusion proof against ğ‘†. This retrieved query result will then be returned back to the DEX's smart contract's handler function. The handler function will be able to match the stored ğ‘ğ‘¢ğ‘’ğ‘Ÿğ‘¦_ğ‘–ğ‘‘ with the returned query result and adjust the liquidity farming schedule based on the volume data.

zkFabric PoC: Ethereum PoS, Cosmos Tendermint, BNB Chain Light Client ZK Circuits and ZK Bridge
Although on-chain light client solutions are trust-minimized in theory, they are prohibitively expensive to implement in practice. Brevis addresses this challenge by combining light client protocol and ZKP, where zkFabric generates a ZK Consensus Proof for all connected blockchains and stores the corresponding block headers in zkAggregatorRollup. In the initial Proof of Concept of zkFabric, we implement light client protocols in the ZK circuits for Ethereum PoS, Cosmos Tendermint, and BNB Chain.

Light client for Ethereum PoS. The circuit for the Ethereum PoS light client mainly consists of 2 sub-circuits. One is the SSZ Sync Committee Commitment circuit that updates the SSZ commitment for the 512 current validators in the sync committee, which rotates every 27 hours. The other is the aggregate BLS12-381 signature verification for the 512 validators, which mainly conducts hash-to-curve calculations and BLS12-381 pairing over the scalar field of BN254 so that it can be efficiently verified in Ethereum smart contracts. Here, the non-native pairing requires a massive non-native field of arithmetics. Following various tricks for BLS pairing implementations and using the efficient range check gadgets provided by gnark, we are able to achieve the accelerated BLS12-381 signature verification over BN254 scalar field when compared to existing implementations. For the SSZ Sync Committee Commitment circuit, we are working on the optimizations using lookup tables and will release an optimized circuit soon.
Light client for Cosmos Tendermint and BNB Chain. The BNB chain adopts a two-layer architecture, comprising the base layer, referred to as the BNB Beacon Chain (BBC), and the execution layer, called the BNB Smart Chain (BSC). The BBC utilizes Tendermint consensus, while the BSC employs a Proof-of-Authority (PoA) consensus called Parli. Each BSC block is signed off by one of the validators in the set. As a specialized Tendermint application, the BBC manages the election and updates of the BSC validator set. Every 24 hours, a new set of BSC validators are elected and synchronized to the BSC via an IBC-like cross-chain mechanism that predates the official IBC specification. For the BBC (essentially Tendermint), the light client mainly involves verifying a batch of Ed25519 signatures, which are expensive to verify directly on-chain. We implement the non-native Ed25519 signature verifications over the BN254 scalar field in gnark. Using the range check gadgets in gnark, we achieve state-of-the-art performance for non-native Ed25519 signature verification. For BSC, the PoA consensus involves secp256k1 signature verifications which are verified directly in the smart contract due to the existence of pre-compiles.
The aforementioned circuits are implemented in gnark and open-source. Their benchmark performance is shown in Table 1 at the beginning of this blog. Note that we are continuously optimizing the circuit and also expect to utilize hardware acceleration and parallelization in the near future.
Additionally, Nearly all existing interoperability solutions fall into the â€œexternal validation model" which necessitates trust in an intermediary entity. As a first step, we built a proof-of-concept demo for a ZK Bridge between the Goerli testnet and the BNB Chain Testnet demonstrating the capabilities of Brevis. Built upon the light clients, we built a bi-directional asset ZK bridge between the Goerli testnet and the BNB Chain Testnet. It should be noted that for the Goerli-to-BNB direction, the expected bridge delay is about 25 minutes since the block header that includes the source chain tx is only considered finalized and relayed after 2-3 epochs (64-96 blocks).
Numerous Exciting Use Cases Enabled by Brevis
Aside from the above example of a ZK Bridge, Brevis empowers developers to create dApps that can access omnichain data across arbitrary time horizons in a way that was previously impossible. This innovation will undoubtedly establish a new paradigm, transforming how dApps are developed across all sectors. In this section, we will present several immediate applications, however we anticipate the community will discover many more use cases.

Data-driven DeFi
In addition to the liquidity farming reward auto-adjustment example discussed previously, we believe data-driven DeFi will become a broad class of applications leveraging Brevis, thanks to the scalability and privacy it enables.

With trust-free access to comprehensive historical and omnichain trading flows, derivatives such as options can now incorporate novel exercise conditions, like Exponential Time Weighted Price or Time-Volume Weighted Price. Alternative derivatives tracking user behavior, price trends, protocol or blockchain TVL changes, volatility, price correlations, and more will also be possible through various implementations of ZQEs.

On-chain active fund management solutions can generate ZK proofs demonstrating that position adjustments are based solely on specific algorithmic models derived from market data, without any unauthorized human intervention. Furthermore, due to the privacy-preserving property of Brevis, the precise model parameters can remain concealed to maintain a competitive market advantage.

User Acquisition with Trust-Free Revenue Sharing
In Web 2.0, the user acquisition process ends when a user downloads or registers, with advertisers paying a fixed price for all users, regardless of their Lifetime Value. This arrangement is not ideal for both advertisers and advertising channels, as the former cannot differentiate user value, and the latter cannot share long-term revenue. This issue arises because post-acquisition user data is private and inaccessible to advertising channels.

Web3 can potentially change this model, as most of the user activity data is public. However, current platforms still follow the Web 2.0 paradigm. Brevis revolutionizes this by allowing advertising channels to generate trustâ€“free revenue proofs for acquired users. This will lead to a fundamental shift in Web 3.0 user acquisition, where advertisers pay only for high-value users, and advertising channels are incentivized to optimally match users with advertisers.
zkDID
Brevis is an essential tool for constructing trust-free zkDID solutions, helping prevent Sybil Attacks and facilitating user life cycle management in various use cases. By generating ZK proofs based on hard-to-fake on-chain behaviors, Brevis enables dApp developers to operate in a fully trust-free manner while preventing Sybil Attacks in campaigns or rollouts.

By leveraging query results and data of aggregated user behaviors, a trust-free user life cycle management process can be built, allowing for loyalty systems, VIP trader programs, and LiveOps campaigns in blockchain gaming. Brevis offers several advantages over in-app accounting, such as lower costs, future-proofing, and portability. zkDIDs generated via Brevis are stored in zkAggregatorRollup, making them accessible to different applications.

Account Abstraction
Brevis offers a compelling use case in Account Abstraction (AA) by improving security and usability in blockchain applications. One key benefit is social recovery, which helps regain wallet access even when the main controlling key is lost. Brevis enables smart wallets to implement social recovery based on recent transaction connections rather than a fixed set of external wallets. This approach reduces maintenance overhead and lowers the entry barrier for new users in the blockchain ecosystem.

Brevis also has potential applications in many other areas such as social and NFT gaming. We encourage developers to explore and discover more exciting use cases for Brev





Honey, I Shrunk the Proof: Enabling on-chain verification for RISC Zero & Bonsai

PAUL GAFNI
INSTRUCTIONAL DESIGN ENGINEER
August 8, 2023
Last week, we posted and verified our first proof on Ethereum's Sepolia Testnet! This is a huge step toward empowering builders to harness the power of ZKPs in their app development. We're excited to enable builders to make use of complex logic in on-chain applications, without ballooning gas costs. Being able to post and verify proofs on-chain makes it possible for Ethereum developers to build off-chain scaling solutions with Bonsai today.


â€

If you're building on Ethereum, you should be thinking about using a zk coprocessor to reduce your gas costs. The core idea is that zkVMs create the opportunity to move the complex part of your application logic off-chain. This means you can have contracts that rely on complex application logic without having to pay gas for that application logic.

Cost will vary a bit based on your application, but for this demo, our costs were:

- 29k gas to request a proof
- 279k gas for the callback

In today's prices, that's less than $15 USD to post & verify a proof on-chain!
$15 may sound expensive for posting & verifying a single proof, but keep in mind that a single proof can represent an arbitrarily large computation or an arbitrarily large batch of computations.

Want to prove the validity of a digital signature? $15.

Want to prove the validity of 1 million digital signatures? Also $15.

When you use a zk coprocessor, you can increase the complexity of your app without impacting gas costs.
â€

Q: Wait, what's a zk coprocessor?

A zk coprocessor is a tool for using ZKPs to offloading computation from on-chain to off-chain. ZK coprocessors are the answer for enabling complex application logic for on-chain applications in a way that will actually scale.

â€

Q: How well does this scale?

A: Gas costs for posting and verifying proofs on-chain *do not depend on the complexity of the computation*. Whether your computation takes 1 million steps or 4 billion steps -- whether it represents one transaction of 1 million transactions -- the gas cost for posting and verifying the proof will be the same. There are two ways that costs will vary with the complexity of the application:

- The gas cost to post & verify the proof depends on the size of the journal (i.e., the public outputs that are being proven).

- The computational cost to generate a proof depends on the complexity of the computation.

â€

Q: I thought RISC Zero's proofs were too big for on-chain verification. How is this possible?

Enabling on-chain verification involved two major engineering milestones:

- a STARK-to-SNARK wrapper

- a Solidity verifier


Our STARK-to-SNARK wrapper reduces our proof size from hundreds of kilobytes to hundreds of bytes. The key idea here is to verify our STARK proof inside a Groth16 prover. Then, we can verify the (much smaller) Groth16 proof on-chain.

With this in place, posting proofs on-chain becomes feasible, as does on-chain verification. With our on-chain verifier contract up and running, using Bonsai as a zk coprocessor is now a real thing.

â€

Q: If I'm building an app with Bonsai, is on-chain verification available to me?

As of this writing, Bonsai is set up to return small proofs that can be cheaply verified on-chain. If you're generating proofs using Bonsai, you can easily post & verify these proofs on Sepolia today. Request Bonsai access and check out the Bonsai Quick Start page to start building.

â€

â€Q: Is this ready to use in production?â€

No. Although you can do experiments and proofs of concept with on-chain verification of RISC Zero proofs today, this is not ready for production. In particular, we have not performed a trusted setup ceremony for Groth16 for our SNARK-to-STARK code, and so our use of Groth16 should not yet be considered secure

â€

Q: Whatâ€™s next?

- We're continuing to optimize the performance of our prover -- check out our datasheet.
- We're working with Nethermind to audit our zkVM.
- We're working with OP Labs to add zk to their stack.
- We're working to stabilize our APIs for the zkVM and Bonsai.

For now, why not start building? You can request access to our remote proving service here, and you can start building using local proving options right now. As always, find us on Discord if you have questions or want to connect.




æ‹†è§£ä»¥å¤ªåŠ ZK åå¤„ç†å™¨ Axiom æŠ€æœ¯ä¼˜åŠ¿
Mask Network ï½œ2023-07-20 9:28
ETHShanghai 2023 å³°ä¼šä¸­ï¼ŒAxiom åˆ›å§‹äºº Yi Sun ä»‹ç»äº†ä»¥å¤ªåŠçš„ ZK åå¤„ç†å™¨ Axiom ä»¥åŠå…¶åœ¨æ•°æ®è®¿é—®å’Œè®¡ç®—èƒ½åŠ›æ–¹é¢çš„é‡è¦æ€§ã€‚Axiom é€šè¿‡ Reflection æ“ä½œæ¦‚å¿µå®ç°äº†æ•°æ®è®¿é—®å’Œè®¡ç®—çš„æ‰©å±•ï¼Œé€šè¿‡éªŒè¯å“ˆå¸Œé“¾å’Œç»´æŠ¤ç¼“å­˜æ¥å®ç°æŸ¥è¯¢çš„æœ‰æ•ˆæ€§ã€‚Axiom çš„åº”ç”¨å‰æ™¯åŒ…æ‹¬é«˜æˆæœ¬åº”ç”¨ã€æ›´å¤§æ•°æ®è®¿é—®ã€åŸºäºå†å²æ•°æ®ç®¡ç†åè®®çš„åº”ç”¨ç­‰ã€‚é€šè¿‡ Axiomï¼Œæ™ºèƒ½åˆçº¦å¯ä»¥è·å¾—æ›´å¹¿é˜”çš„æ•°æ®å’Œè®¡ç®—èƒ½åŠ›ï¼Œè¿›ä¸€æ­¥æ¨åŠ¨ä»¥å¤ªåŠåº”ç”¨çš„å‘å±•ã€‚
ETHShanghai 2023 å³°ä¼šä¸­ï¼ŒAxiom åˆ›å§‹äºº Yi Sun ä»‹ç»äº†ä»¥å¤ªåŠçš„ ZK åå¤„ç†å™¨ Axiom ä»¥åŠå…¶åœ¨æ•°æ®è®¿é—®å’Œè®¡ç®—èƒ½åŠ›æ–¹é¢çš„é‡è¦æ€§ã€‚Axiom é€šè¿‡ Reflection æ“ä½œæ¦‚å¿µå®ç°äº†æ•°æ®è®¿é—®å’Œè®¡ç®—çš„æ‰©å±•ï¼Œé€šè¿‡éªŒè¯å“ˆå¸Œé“¾å’Œç»´æŠ¤ç¼“å­˜æ¥å®ç°æŸ¥è¯¢çš„æœ‰æ•ˆæ€§ã€‚Axiom çš„åº”ç”¨å‰æ™¯åŒ…æ‹¬é«˜æˆæœ¬åº”ç”¨ã€æ›´å¤§æ•°æ®è®¿é—®ã€åŸºäºå†å²æ•°æ®ç®¡ç†åè®®çš„åº”ç”¨ç­‰ã€‚é€šè¿‡ Axiomï¼Œæ™ºèƒ½åˆçº¦å¯ä»¥è·å¾—æ›´å¹¿é˜”çš„æ•°æ®å’Œè®¡ç®—èƒ½åŠ›ï¼Œè¿›ä¸€æ­¥æ¨åŠ¨ä»¥å¤ªåŠåº”ç”¨çš„å‘å±•ã€‚

ä»¥ä¸‹æ­£æ–‡ä¸º Yi Sun æ¼”è®²å†…å®¹çš„ä¸­æ–‡ç¼–è¯‘ç‰ˆæœ¬ï¼Œé“¾æ¥ä¸ºç°åœºè§†é¢‘ï¼šhttps://www.youtube.com/watch?v=qxSQNbf_SXs

é¦–å…ˆï¼Œæˆ‘ä»¬æ¥äº†è§£å®é™…è®¿é—®ä»¥å¤ªåŠä¿¡æ¯çš„ç”¨æˆ·æ—…ç¨‹ã€‚å½“æˆ‘ä»¬ç¬¬ä¸€æ¬¡ä½¿ç”¨ä»¥å¤ªåŠæ—¶ï¼Œå®é™…æ¥æ”¶æœ‰å…³é“¾ä¸Šå‘ç”Ÿçš„æƒ…å†µçš„ä¿¡æ¯çš„æ–¹å¼æ˜¯é€šè¿‡å¯¹å­˜æ¡£æ³¨é‡Šçš„ JSON-RPC è°ƒç”¨ã€‚JSON-RPC API çš„ç›®çš„æ˜¯å®é™…å‘ç”¨æˆ·å±•ç¤ºæœ‰å…³é“¾ä¸Šå†å²çš„ä¿¡æ¯ã€‚æœ¬è´¨ä¸Šï¼Œæˆ‘ä»¬çœ‹åˆ°çš„æœ‰å…³åŒºå—é“¾çš„æ‰€æœ‰ä¿¡æ¯éƒ½æ˜¯ä»è¿™äº› API è°ƒç”¨ä¸­æå–å‡ºæ¥çš„ï¼Œå¹¶ä»¥ä¸€ç§æ¡ç›®çš„å½¢å¼å‘ˆç°åœ¨ç½‘ç«™ä¸Šä¾›ç”¨æˆ·è¯»å–ã€‚

ç°åœ¨ï¼Œéšç€ç”¨æˆ·ä¸åŒºå—é“¾äº¤äº’å˜å¾—æ›´åŠ ç†Ÿç»ƒï¼Œæˆ‘ä»¬å¼€å§‹è¦æ±‚å¯¹é“¾çš„è§†å›¾è¶Šæ¥è¶Šå¤æ‚ã€‚ å› æ­¤ï¼Œé’ˆå¯¹ä¸åŒçš„ç”¨æˆ·æƒè¡¡ï¼Œæ­£åœ¨å¼€å‘ä¸åŒç±»å‹çš„å­˜æ¡£èŠ‚ç‚¹ã€‚ äºæ˜¯å°±æœ‰äº† Gethã€Erigonã€Nethermindï¼Œç°åœ¨åˆå¢åŠ äº† Rethã€‚æˆ‘ä»¬å¯æ ¹æ®è‡ªèº«éœ€æ±‚é€‰æ‹©æœ€é€‚åˆè‡ªå·±çš„å­˜æ¡£èŠ‚ç‚¹ã€‚

å¦‚æœç”¨æˆ·å¯¹å•ç‹¬çš„ JSON-RPC API ä¸æ»¡æ„ï¼Œå¯ä»¥é€‰æ‹©ä¸€ä¸ªç´¢å¼•å™¨æ¥åº”ç”¨åå¤„ç†ï¼ŒåŒæ—¶è·Ÿè¸ªäº¤æ˜“ã€‚å¯¹äºä¸åŒçš„åº”ç”¨ç¨‹åºï¼Œç”¨æˆ·å¯èƒ½å¯¹ä» The Graph æˆ– Covalent è¿”å›çš„æ•°æ®æ„Ÿå…´è¶£ã€‚

æœ€è¿‘ï¼Œè¿˜å‡ºç°äº†ä¸€äº›é’±åŒ…å’Œå…¶ä»–äº§å“ï¼Œæä¾›åœ¨å­˜æ¡£èŠ‚ç‚¹ä¹‹ä¸Šè¿›è¡Œäº¤æ˜“æ¨¡æ‹Ÿçš„åŠŸèƒ½ã€‚è¿™æ„å‘³ç€æˆ‘ä»¬å¯ä»¥åœ¨æäº¤äº¤æ˜“ä¹‹å‰çœ‹åˆ°è™šæ‹Ÿäº¤æ˜“çš„å®é™…ç»“æœã€‚æ€»çš„æ¥è¯´ï¼Œä½œä¸ºæœ€ç»ˆç”¨æˆ·ï¼Œæˆ‘ä»¬ä¸ä»¥å¤ªåŠçš„äº¤äº’æ–¹å¼è¶Šæ¥è¶Šå¤æ‚ï¼Œå®ƒåœ¨æˆ‘ä»¬è¯»å–çš„æ•°æ®ä¹‹ä¸Šä½¿ç”¨äº†æ›´å¤šçš„è®¡ç®—ã€‚

ç°åœ¨ï¼Œå¦‚æœæˆ‘ä»¬ä¸æ˜¯ä»ç”¨æˆ·çš„è§’åº¦ï¼Œè€Œæ˜¯ä»ä»¥å¤ªåŠä¸Šçš„æ™ºèƒ½åˆçº¦çš„è§’åº¦æ¥è€ƒè™‘é—®é¢˜ã€‚å½“ç„¶ï¼Œåˆçº¦ä¹Ÿå¸Œæœ›èƒ½å¤Ÿè®¿é—®æ•°æ®å¹¶å¯¹æ•°æ®è¿›è¡Œè®¡ç®—ï¼Œä½†è¿™æ›´å…·æŒ‘æˆ˜æ€§ã€‚äº‹å®ä¸Šï¼Œå¦‚æœæˆ‘ä»¬å» OpenSea çœ‹çœ‹ CryptoPunk çš„åˆ—è¡¨ï¼Œä¼šå‘ç°åœ¨é¡µé¢ä¸Šçš„æ‰€æœ‰ä¿¡æ¯ä¸­ï¼Œåªæœ‰å¾ˆå°ä¸€éƒ¨åˆ†æ˜¯åœ¨é“¾ä¸Šçš„æ™ºèƒ½åˆçº¦ä¸­å¯ä»¥è®¿é—®çš„ã€‚

äº‹å®ä¸Šï¼Œå¯¹äº CryptoPunk çš„åˆ—è¡¨ï¼Œè¿™äº›ä¿¡æ¯åªæ˜¯å½“å‰çš„æŒæœ‰è€…ã€‚å½“ç„¶ï¼Œé¡µé¢ä¸Šè¿˜æœ‰å¾ˆå¤šå…¶ä»–ä¿¡æ¯ï¼Œä½†ä¸å†å²è½¬è´¦ä¿¡æ¯ã€å†å²ä»·æ ¼å’Œå†å²æŒæœ‰è€…ç›¸å…³çš„æ‰€æœ‰ä¿¡æ¯å®é™…ä¸Šå¯¹æ™ºèƒ½åˆçº¦æ˜¯ä¸å¯è®¿é—®çš„ï¼Œå› ä¸ºå®ƒå±äºè¿‡å»çš„å†å²ã€‚è¿™äº›å†å²æ„æˆäº†é“¾ä¸Šä¿¡æ¯ï¼Œä½†å¯¹äºæ™ºèƒ½åˆçº¦æ¥è¯´ï¼Œå®ƒä»¬ä¸å¯ç”¨ï¼Œå› ä¸ºæˆ‘ä»¬éœ€è¦é¿å…å¼ºåˆ¶è¦æ±‚æ¯ä¸ªå®Œæ•´çš„ä»¥å¤ªåŠèŠ‚ç‚¹åœ¨å…¶éšæœºè®¿é—®ä¸­ç»´æŠ¤æ­¤ä¿¡æ¯ä»¥éªŒè¯äº¤æ˜“ã€‚

æ­¤å¤–ï¼Œä»»ä½•åŒºå—é“¾å¼€å‘äººå‘˜éƒ½å¯ä»¥å‘Šè¯‰ä½ ï¼Œåœ¨é“¾ä¸Šè¿è¡Œè®¡ç®—æ˜¯éå¸¸æ˜‚è´µçš„ï¼Œå°½ç®¡ä»¥å¤ªåŠå…·æœ‰ç›¸å¯¹é«˜æ•ˆçš„è™šæ‹Ÿæœºï¼ˆVMï¼‰æ“ä½œï¼Œå¹¶ä¸”é€šè¿‡é¢„ç¼–è¯‘ä½¿æŸäº›ç±»å‹çš„æ“ä½œæ›´ä¾¿å®œã€‚ä¾‹å¦‚ï¼Œåœ¨ BN254 æ›²çº¿ä¸Šçš„æ¤­åœ†æ›²çº¿è¿ç®—ï¼Œä»¥å¤ªåŠæä¾›äº†ä»·æ ¼è¾ƒä¸ºä½å»‰çš„æ”¯æŒã€‚ç„¶è€Œï¼Œå¯¹äºä¸€äº›ç‰¹å®šçš„åº”ç”¨ç¨‹åºï¼Œä»¥å¤ªåŠè™šæ‹Ÿæœºä»ç„¶æ˜¯ä¸€ä¸ªéå¸¸æ˜‚è´µçš„è¿è¡Œç¯å¢ƒã€‚å½“è®¾è®¡ä¸€ä¸ªåŒºå—é“¾è™šæ‹Ÿæœºæ—¶ï¼Œå¿…é¡»é€‰æ‹©ä¸€ç»„å›ºæœ‰çš„æ“ä½œï¼Œè¿™äº›æ“ä½œéœ€è¦ä»”ç»†è®¡é‡ï¼Œä»¥ç¡®ä¿æ¯ä¸ªèŠ‚ç‚¹éƒ½èƒ½ä»¥ä¸€è‡´çš„æ—¶é—´éªŒè¯äº¤æ˜“ã€‚æ­¤å¤–ï¼Œè¿˜å¿…é¡»è€ƒè™‘æœ€åæƒ…å†µä¸‹çš„å®‰å…¨æ€§å’Œå…±è¯†ç¨³å®šæ€§ã€‚å› æ­¤ï¼Œè¿™é‡Œçš„æŒ‘æˆ˜åœ¨äºå¦‚ä½•å®ç°é’ˆå¯¹é“¾ä¸Šåº”ç”¨ç¨‹åºçš„åº”ç”¨ç‰¹å®šæ‰©å±•ã€‚Axiom æ—¨åœ¨ä¸ºæ™ºèƒ½åˆçº¦æ‰©å±•æ•°æ®è®¿é—®å’Œè®¡ç®—èƒ½åŠ›ï¼Œæ»¡è¶³ä¸åŒåº”ç”¨çš„æ‹“å±•éœ€æ±‚ã€‚

æ‹†è§£ä»¥å¤ªåŠ ZK åå¤„ç†å™¨ Axiom æŠ€æœ¯ä¼˜åŠ¿

Axiom æ­£åœ¨æ„å»ºçš„æ˜¯ç§°ä¹‹ä¸ºä»¥å¤ªåŠåå¤„ç†å™¨ï¼ˆZK Coprocessorï¼‰ï¼Œé€šè¿‡ä»¥ä¸Šæ“ä½œå…è®¸æŸäº›æ™ºèƒ½åˆçº¦æ— éœ€ä¿¡ä»»åœ°å§”æ‰˜ç»™æˆ‘ä»¬çš„ç¦»çº¿ç³»ç»Ÿï¼Œä»¥ä¾¿å®ƒä»¬å¯ä»¥å°†æ•°æ®è¯»å–å’Œå¯éªŒè¯è®¡ç®—å§”æ‰˜ç»™ Axiomã€‚è¦å‘ Axiom å‘å‡ºæŸ¥è¯¢ï¼Œæ™ºèƒ½åˆçº¦å¯ä»¥å‘æˆ‘ä»¬çš„é“¾ä¸Šç³»ç»Ÿå‘é€ä¸€ç¬”äº¤æ˜“ã€‚æˆ‘ä»¬çš„ç¦»çº¿èŠ‚ç‚¹å°†æ¥æ”¶è¯¥äº¤æ˜“ï¼Œå¹¶æ ¹æ®ä»¥å¤ªåŠçš„å†å²æŸ¥è¯¢ç”Ÿæˆç»“æœï¼Œå¹¶é™„ä¸Šä¸€ä¸ªé›¶çŸ¥è¯†è¯æ˜ï¼Œä»¥è¯æ˜ç»“æœçš„æ­£ç¡®æ€§ã€‚æœ€åï¼Œæˆ‘ä»¬å†é“¾ä¸ŠéªŒè¯ç»“æœï¼Œå¹¶å¯ä¿¡åœ°å°†ç»“æœäº¤ä»˜ç»™ä¸‹æ¸¸çš„æ™ºèƒ½åˆçº¦ã€‚

è¿™ç§æ–¹å¼ç±»ä¼¼äºè®¡ç®—æœºä¸­çš„ CPU å°†è®¡ç®—ä»»åŠ¡å§”æ‰˜ç»™ GPUï¼Œå¹¶åœ¨ç»“æœå¯çŸ¥åå°†å…¶å–å›ã€‚è¿™ä¸ªæ¦‚å¿µåœ¨æ—©æœŸè¢«ç§°ä¸ºåå¤„ç†å™¨ï¼ˆCoprocessoï¼‰ã€‚åœ¨å¹»ç¯ç‰‡ä¸Šï¼Œæˆ‘å±•ç¤ºäº†ä¸Šä¸–çºª 90 å¹´ä»£åˆçš„ä¸€ä¸ªé«˜çº§æ•°å­¦ Coprocesso çš„å›¾åƒä¸ Axiom æ‰€åšçš„ç±»æ¯”ã€‚

æ‹†è§£ä»¥å¤ªåŠ ZK åå¤„ç†å™¨ Axiom æŠ€æœ¯ä¼˜åŠ¿

æˆ‘ä»¬å¯ä»¥æ·±å…¥åœ°äº†è§£ Axiom å¯ä»¥è¿›è¡Œå“ªäº›ç±»å‹çš„æ“ä½œæ¯ä¸ªå¯¹ Axiom çš„æŸ¥è¯¢å¯ä»¥åˆ†ä¸ºä¸‰ä¸ªéƒ¨åˆ†ã€‚

é¦–å…ˆæ˜¯è¯»å–éƒ¨åˆ†ï¼Œä¹Ÿæ˜¯ Axiom æŸ¥è¯¢çš„è¾“å…¥æ–¹å¼â€”â€”æˆ‘ä»¬å¯ä»¥å¯ä¿¡åœ°è¯»å–å†å²ä¸Šé“¾çš„æ•°æ®ã€‚

ç¬¬äºŒéƒ¨åˆ†æ˜¯æˆ‘ä»¬å¯ä»¥åœ¨è¿™äº›æ•°æ®ä¸Šè¿è¡ŒéªŒè¯è®¡ç®—ã€‚è¿™å¯èƒ½ä»åŸºæœ¬çš„åˆ†æå¼€å§‹ï¼Œæ¯”å¦‚å¯¹ä¸€äº›æ•°å­—æ±‚å’Œã€æ±‚æœ€å¤§å€¼æˆ–æœ€å°å€¼ï¼Œåˆ°æ›´å¤æ‚çš„è®¡ç®—ã€‚æ¯”å¦‚æ¥è‡ªå¯†ç å­¦çš„ä¸€äº›ç­¾åèšåˆæˆ–éªŒè¯ï¼Œç”šè‡³å¯ä»¥è¿›è¡ŒåŸºäºé›¶çŸ¥è¯†çš„æœºå™¨å­¦ä¹ ï¼Œæ¯”å¦‚åœ¨é“¾ä¸Šç¤¾äº¤æ•°æ®ä¸ŠéªŒè¯æŸäº›å£°èª‰ç®—æ³•çš„è¿è¡Œæˆ–åœ¨é‡‘èåº”ç”¨ä¸­ä½¿ç”¨æŸäº›æœºå™¨å­¦ä¹ ç®—æ³•ã€‚æœ€ç»ˆï¼Œæˆ‘ä»¬å°†é€šè¿‡è™šæ‹Ÿæœºæä¾›å¯ç¼–ç¨‹çš„è®¡ç®—å¤åˆåŠŸèƒ½ã€‚

æœ€åä¸€ä¸ªéƒ¨åˆ†ï¼Œåœ¨è¯»å–å’Œè®¡ç®—æ­¥éª¤å®Œæˆåï¼Œæˆ‘ä»¬å¾—åˆ°ä¸€ä¸ªç»“æœï¼Œå¹¶ä¸”å§‹ç»ˆå°†è¯¥ç»“æœä¸é›¶çŸ¥è¯†è¯æ˜é…å¯¹ï¼Œä»¥è¯æ˜ç»“æœçš„è®¡ç®—æ˜¯æœ‰æ•ˆçš„ã€‚å› æ­¤ï¼Œæˆ‘ä»¬åœ¨ä»¥å¤ªåŠæ™ºèƒ½åˆçº¦ä¸­éªŒè¯è¯¥è¯æ˜ï¼Œç„¶åå°†ç»“æœå­˜å‚¨ä¾›åˆçº¦ä½¿ç”¨ã€‚

ç”±äº Axiom è¿”å›çš„æ‰€æœ‰ç»“æœå®é™…ä¸Šéƒ½ç»è¿‡é›¶çŸ¥è¯†è¯æ˜éªŒè¯ï¼Œè¿™æ„å‘³ç€ Axiom è¿”å›çš„æ‰€æœ‰å†…å®¹çš„å®‰å…¨æ€§ä¸ä»¥å¤ªåŠæœ¬èº«çš„å®‰å…¨æ€§åœ¨å¯†ç å­¦ä¸Šæ˜¯ç­‰æ•ˆçš„ã€‚Axiom çš„ç†å¿µæ˜¯ï¼Œæˆ‘ä»¬ä¸å¸Œæœ›å¯¹ç”¨æˆ·æ–½åŠ ä»»ä½•è¶…å‡ºå…¶ä½¿ç”¨ä»¥å¤ªåŠæ‰€å·²æœ‰çš„å¯†ç å­¦å‡è®¾çš„é¢å¤–å‡è®¾ã€‚

æ¥ä¸‹æ¥æˆ‘å°†è¯¦ç»†ä»‹ç»å®ƒçš„å®ç°åŸç†ï¼Œè¿™æ¶‰åŠåˆ°åœ¨æ¼”è®²æ ‡é¢˜ä¸­æåˆ°çš„ Reflection æ“ä½œæ¦‚å¿µã€‚å®ç°è¿™ä¸€åˆ‡çš„æ ¸å¿ƒåŸåˆ™æ˜¯ï¼Œæ¯ä¸ªåŒºå—é“¾ä¸Šçš„åŒºå—éƒ½åŒ…å«äº†å®Œæ•´çš„å†å²è®°å½•ã€‚æˆ‘ä»¬å¯ä»¥ä»å½“å‰çš„ä»¥å¤ªåŠåŒºå—å¼€å§‹ï¼Œå‘å‰å›æº¯åˆ°æˆ‘ä»¬æ„Ÿå…´è¶£çš„æ—©æœŸåŒºå—ã€‚é€šè¿‡è·å–è¿‡å»åŒºå—å’Œå½“å‰åŒºå—ä¹‹é—´çš„æ‰€æœ‰åŒºå—å¤´ï¼Œå¹¶é€šè¿‡éªŒè¯è¿™äº›åŒºå—å¤´çš„å“ˆå¸Œé“¾ï¼Œæˆ‘ä»¬å®é™…ä¸Šå¯ä»¥å°†è¿‡å»åŒºå—çš„æ‰¿è¯ºé€†å‘è¿½æº¯åˆ°å½“å‰åŒºå—ã€‚

é‚£ Reflection æœ‰ä»€ä¹ˆå¥½å¤„å‘¢ï¼Ÿ

æˆ‘ä»¬å¯ä»¥å–å½“å‰ä»¥å¤ªåŠçš„ä¸€ä¸ªå—ï¼Œå¹¶å›æº¯åˆ°æˆ‘ä»¬æ„Ÿå…´è¶£çš„ä»¥å‰çš„ä¸€ä¸ªå—ã€‚å¦‚æœæˆ‘ä»¬å–å¾—è¿‡å»å—å’Œå½“å‰å—ä¹‹é—´çš„å—å¤´ï¼Œæˆ‘ä»¬å¯ä»¥é€šè¿‡éªŒè¯è¿™äº›å—å¤´ä¹‹é—´çš„å“ˆå¸Œè·¯å¾„ï¼Œå°†è¿‡å»å—çš„æ‰¿è¯ºåå‘åˆ°å½“å‰å—ä¸­ã€‚ç„¶åï¼Œå¦‚æœæˆ‘ä»¬å¯¹è¿‡å»å—ä¸­çš„æŸäº›ä¿¡æ¯æ„Ÿå…´è¶£ï¼Œæˆ‘ä»¬å¯ä»¥åœ¨è¯¥å—çš„æ‰¿è¯ºä¸­ç»™å‡ºä¸€ä¸ªåŒ…å«è¯æ˜ã€‚å…·ä½“æ¥è¯´ï¼Œè¿™å¯ä»¥æ˜¯ä¸€ä¸ª Merkle Patricia Trie è¯æ˜ï¼Œè¯æ˜è¯¥ä¿¡æ¯å­˜åœ¨äºè¯¥å—çš„çŠ¶æ€ trieã€äº¤æ˜“ trie æˆ–æ”¶æ® trie ä¸­ã€‚è‡³å°‘åŸåˆ™ä¸Šï¼Œåœ¨ EVM ä¸­ï¼Œä»…é€šè¿‡å¯¹æœ€è¿‘å—å“ˆå¸Œçš„äº†è§£ï¼Œå°±å¯ä»¥è®¿é—®é“¾ä¸Šçš„ä»»ä½•è¿‡å»ä¿¡æ¯ã€‚

é—æ†¾çš„æ˜¯ï¼Œåœ¨ EVM ä¸­è¿›è¡Œè¿™æ ·æ“ä½œçš„ä»£ä»·æ˜¯æ˜‚è´µçš„ã€‚æ­£å¦‚åˆšåˆšæåˆ°çš„ï¼Œä½ å¿…é¡»éªŒè¯æ‰€æœ‰å—å¤´çš„å“ˆå¸Œé“¾å’Œ Merkle è¯æ˜ï¼Œè¿™æ¶‰åŠå¯¹å¤§é‡æ•°æ®è¿›è¡Œè®¸å¤š Keccak å“ˆå¸Œè®¡ç®—ã€‚æ‰€ä»¥ä¸€æ—¦ä½ å›æº¯åˆ°è¿‡å»ï¼Œå°±ä¼šå˜å¾—éå¸¸å›°éš¾ã€‚å› æ­¤ï¼Œæˆ‘ä»¬é€šè¿‡åœ¨ EVM ä¸­ä½¿ç”¨ ZK å°è£…è¿™ä¸ªè¯æ˜æ¥åº”ç”¨ Reflection æ“ä½œã€‚å› æ­¤ï¼Œæˆ‘ä»¬ä¸éœ€è¦å°†æ‰€æœ‰è¿‡å»çš„å—å¤´å’Œæ‰€æœ‰è¿™äº› Merkle è¯æ˜æ”¾åœ¨é“¾ä¸Šï¼Œç„¶åè¿›è¡ŒéªŒè¯ï¼Œè€Œæ˜¯åœ¨é›¶çŸ¥è¯†ä¸­æ£€æŸ¥æ˜¯å¦å­˜åœ¨ä¸€ç³»åˆ—è¿‡å»çš„å—å¤´å’Œä¸€äº›éªŒè¯çš„è¯æ˜ã€‚

è¿™æœ‰ä¸¤ä¸ªä¼˜ç‚¹ã€‚é¦–å…ˆï¼Œå®ƒä½¿æˆ‘ä»¬ä¸å¿…å°†è¯æ˜æ•°æ®æ”¾å…¥è°ƒç”¨æ•°æ®ä¸­ã€‚å…¶æ¬¡ï¼Œå®ƒè®©æˆ‘ä»¬èƒ½å¤Ÿå°†è¯æ˜èšåˆï¼Œè€Œå¦‚æœæ²¡æœ‰ä½¿ç”¨ ZK çš„è¯ï¼Œè¿™æ˜¯ä¸å¯æƒ³è±¡çš„ã€‚è¿™é‡Œçš„æƒ³æ³•æ˜¯ï¼Œåœ¨ä»¥å¤ªåŠä¸ŠéªŒè¯ä»»æ„æ•°é‡çš„è®¡ç®—æ—¶ï¼ŒGas æˆæœ¬æ˜¯å›ºå®šçš„ï¼Œå› æ­¤æˆ‘ä»¬å¯ä»¥ä½¿ç”¨å•ä¸ª ZK è¯æ˜æ¥éªŒè¯å¤§é‡çš„å†å²æ•°æ®è®¿é—®ã€‚

è®©æˆ‘ç®€å•è°ˆè°ˆåŸºäº ZK çš„ Reflection æ“ä½œæ¦‚å¿µçš„æƒè¡¡ã€‚

è®¿é—®æ•°æ®æœ‰ä¸¤ç§æ–¹å¼ã€‚ç¬¬ä¸€ç§æ˜¯ä½ ä¹‹å‰æ‰€äº†è§£çš„æ–¹å¼â€”â€”ä½ å¯ä»¥ç›´æ¥ä»æ™ºèƒ½åˆçº¦ä¸­è®¿é—®ä»¥å¤ªåŠä¸Šçš„æ•°æ®ã€‚è¿™æœ‰ä¸€ä¸ªéå¸¸å¤§çš„ä¼˜ç‚¹ï¼Œå³è®¿é—®æ˜¯åŒæ­¥çš„ã€‚å› æ­¤ï¼Œä½ å¯ä»¥ç›´æ¥è°ƒç”¨æ™ºèƒ½åˆçº¦ä¸­çš„è¯»å–å‡½æ•°ï¼Œè·å–å½“å‰å€¼ã€‚ä¾‹å¦‚ï¼Œå½“ä½ åœ¨ Uniswap ä¸Šè¿›è¡Œäº¤æ˜“æ—¶ï¼Œä½ å°±éœ€è¦è¿™ç§åŒæ­¥æ€§ã€‚ç„¶è€Œï¼Œå®ƒä¹Ÿæœ‰å¾ˆå¤šé™åˆ¶ã€‚ä½ çš„è®¡ç®—èƒ½åŠ›å—åˆ°ç‡ƒæ–™æˆæœ¬çš„é™åˆ¶ï¼Œè€Œä¸”æ— æ³•è®¿é—®ä»»ä½•å†å²æ•°æ®ã€‚

ç¬¬äºŒç§ï¼Œå¦‚æœä½ æƒ³åˆ©ç”¨ ZK çš„èƒ½åŠ›æ¥åæ˜ åˆ°ä»¥å¤ªåŠä¸­ï¼Œå› ä¸ºä½ å¿…é¡»ç”Ÿæˆè¯æ˜ï¼Œè¯æ˜ä½ çš„è®¿é—®æ˜¯æ­£ç¡®çš„ï¼Œé‚£ä¹ˆå°±æ— æ³•ä»¥åŒæ­¥æ–¹å¼åšåˆ°è¿™ä¸€ç‚¹ã€‚å› æ­¤ï¼Œå®é™…ä¸Šæ— æ³•ç›´æ¥è®¿é—®å½“å‰çš„é“¾ä¸ŠçŠ¶æ€ï¼Œå› ä¸ºä½ å¿…é¡»é’ˆå¯¹ä¸€ä¸ªçŠ¶æ€è¿›è¡Œè¯æ˜ã€‚

å¦ä¸€æ–¹é¢ï¼Œå¦‚æœä½ å…è®¸è‡ªå·±ä»¥å¼‚æ­¥æ–¹å¼è®¿é—®å†å²æ•°æ®ï¼Œé‚£ä¹ˆä½ å¯ä»¥å¯¹å…¶åº”ç”¨å‡ ä¹æ— é™çš„è®¡ç®—ï¼Œå¹¶ä¸”å¯ä»¥è®¿é—®å¤§é‡æ•°æ®ã€‚å› æ­¤ï¼Œé€šè¿‡æ”¾å®½åŒæ­¥çš„æ¦‚å¿µï¼ŒåŸºäº ZK çš„ Reflection æ“ä½œå¼æ•°æ®è®¿é—®å¯ä»¥å¤§å¹…æ‰©å±•ã€‚

æˆ‘ä»¬æ¥ç€äº†è§£å¦‚ä½•é€šè¿‡ Axiom å®ç° Reflection æ“ä½œã€‚

é¦–å…ˆï¼Œæˆ‘ä»¬å®é™…ä¸Šå¿…é¡»åœ¨æˆ‘ä»¬çš„æ™ºèƒ½åˆçº¦ä¸­ç»´æŠ¤æ‰€æœ‰å…ˆå‰å—çš„ç¼“å­˜ã€‚åœ¨ EVM ä¸­ï¼Œæœ€å 256 ä¸ªå—å“ˆå¸Œæ˜¯åŸç”Ÿå¯ç”¨çš„ã€‚æˆ‘ä»¬å¯ä»¥è¯æ˜ï¼Œåœ¨æ¯ 1024 ä¸ªå—çš„æ‰¹æ¬¡ä¸­ï¼Œå‰ä¸€ä¸ªæ‰¹æ¬¡çš„æœ€åä¸€ä¸ªå—çš„å“ˆå¸Œä¼šåœ¨ä¸‹ä¸€ä¸ªå—ä¸­æäº¤ã€‚åŒæ ·ï¼Œå‰ä¸€ä¸ªæ‰¹æ¬¡ä¸­å€’æ•°ç¬¬äºŒä¸ªå—çš„å“ˆå¸Œä¼šåœ¨æœ€åä¸€ä¸ªå—ä¸­æäº¤ï¼Œä»¥æ­¤ç±»æ¨ã€‚å› æ­¤ï¼Œæˆ‘ä»¬å¯ä»¥åå‘éªŒè¯è¿™ä¸ªå“ˆå¸Œé“¾ï¼Œå¹¶é€šè¿‡é›¶çŸ¥è¯†è¯æ˜è¿™ä¸ªå“ˆå¸Œé“¾çš„æœ‰æ•ˆæ€§ã€‚

è¿™ä½¿æˆ‘ä»¬èƒ½å¤Ÿä»æœ€è¿‘çš„å—å¼€å§‹ï¼Œä¸€ç›´ç¼“å­˜åˆ°åˆ›ä¸–å—çš„å—å“ˆå¸Œã€‚å®é™…ä¸Šï¼Œæˆ‘ä»¬åœ¨æˆ‘ä»¬çš„ä¸»ç½‘æ™ºèƒ½åˆçº¦ä¸­å·²ç»å®ç°äº†è¿™ä¸€ç‚¹ï¼Œå®ƒåŒ…å«äº†ä»åˆ›ä¸–å—å¼€å§‹çš„æ¯1024ä¸ªå—å“ˆå¸Œçš„ç¼“å­˜ Merkle è·¯å¾„ã€‚

æˆ‘ä»¬æ­£åœ¨æ·»åŠ çš„å¦ä¸€ä¸ªåŠŸèƒ½æ˜¯ Merkle Mountain Rangeã€‚å®ƒå»ºç«‹åœ¨è¿™ä¸ªå—å“ˆå¸Œç¼“å­˜ä¹‹ä¸Šï¼Œæ˜¯ä¸€ç§æ•°æ®ç»“æ„ï¼Œä½¿æˆ‘ä»¬èƒ½å¤Ÿåœ¨æœ‰é™çš„ DNA ä¸­å¼•ç”¨ä»¥å¤ªåŠä¸­çš„æ¯ä¸ªå—å“ˆå¸Œã€‚

ä¸€æ—¦æˆ‘ä»¬å»ºç«‹äº†ç¼“å­˜ï¼Œæˆ‘ä»¬å¯ä»¥é€šè¿‡å¯¹ç¼“å­˜ä¸­çš„å—è¿›è¡ŒéªŒè¯æ¥æŸ¥è¯¢ Axiomã€‚ä¸ºäº†å®ç°è¿™ä¸€ç‚¹ï¼Œæˆ‘ä»¬å¿…é¡»è¯æ˜æˆ‘ä»¬è¯•å›¾è®¿é—®çš„ä»¥å¤ªåŠå†å²æ•°æ®ä¸­çš„æ¯ä¸ªæ•°æ®å®é™…ä¸Šéƒ½æ‰¿è¯ºåœ¨æŸä¸ªå—çš„ç¼“å­˜ä¸­ã€‚å…¶æ¬¡ï¼Œæˆ‘ä»¬å¿…é¡»è¯æ˜æˆ‘ä»¬åœ¨æ­¤æŸ¥è¯¢ä¸Šæ‰§è¡Œçš„æ‰€æœ‰è®¡ç®—éƒ½æ˜¯æ­£ç¡®çš„ã€‚ä¸ºäº†åœ¨é“¾ä¸Šè¿›è¡Œæ£€æŸ¥ï¼Œæˆ‘ä»¬ä¼šéªŒè¯é›¶çŸ¥è¯†è¯æ˜çš„æœ‰æ•ˆæ€§ã€‚æˆ‘ä»¬è¿˜ä¼šæ£€æŸ¥å®ƒæ˜¯å¦ä¸æˆ‘ä»¬åœ¨é“¾ä¸Šè®°å½•çš„ä¿¡æ¯ç›¸å…³ã€‚æˆ‘ä»¬å§‹ç»ˆå°†ä¿¡ä»»å»ºç«‹åœ¨æˆ‘ä»¬çš„ç¼“å­˜æˆ–å—ç¼“å­˜ä¸­ï¼Œå¹¶å°†è¿™äº›å—ç¼“å­˜ä¸­çš„ä¿¡æ¯ä¸é›¶çŸ¥è¯†è¯æ˜ä¸­çš„å…¬å…±ä¿¡æ¯è¿›è¡ŒåŒ¹é…ã€‚

ç°åœ¨æˆ‘ä»¬æ¥è°ˆè°ˆ Reflection æ“ä½œè®¾æƒ³ä¸­çš„å¯èƒ½åº”ç”¨ã€‚

æ°´å¹³è½´è¡¨ç¤ºæ•°æ®å¤æ‚åº¦ï¼Œå³å®é™…ä¸Šéœ€è¦è®¿é—®å¤šå°‘æ•°æ®æ‰èƒ½å®ç°è¯¥åº”ç”¨ç¨‹åºã€‚å‚ç›´è½´è¡¨ç¤ºè®¡ç®—å¤æ‚åº¦ï¼Œå³ä¸ºå®Œæˆæ­¤ä»»åŠ¡å®é™…ä¸Šéœ€è¦åº”ç”¨å¤šå°‘è®¡ç®—èµ„æºã€‚

æ‹†è§£ä»¥å¤ªåŠ ZK åå¤„ç†å™¨ Axiom æŠ€æœ¯ä¼˜åŠ¿

å› æ­¤ï¼Œç¬¬ä¸€ç±»åº”ç”¨æ˜¯ Axiom æˆ–ä»»ä½•ç±»å‹çš„ Reflection æ“ä½œæœºåˆ¶å¯ä»¥åœ¨ä»¥å¤ªåŠä¸Šå®ç°çš„ï¼Œä½†æˆæœ¬ç¨é«˜çš„åº”ç”¨ã€‚

å…¶ä¸­ä¸€äº›ä¾‹å­åŒ…æ‹¬ä»ä»¥å¤ªåŠå…±è¯†å±‚çš„åŒºå—å¤´ä¸­è¯»å–å…±è¯†çº§éšæœºæ•°ï¼ŒéªŒè¯å†å²è´¦æˆ·å¹´é¾„ï¼Œæˆ–ä»å†å²ä»·æ ¼ä¿¡æ¯ä¸­è¯»å–ä¸åŒç±»å‹çš„é¢„è¨€æœºæ•°æ®ã€‚åœ¨ EVM ä¸­ï¼Œå¯ä»¥é‡‡ç”¨å„ç§è§£å†³æ–¹æ¡ˆæ¥å®ç°è¿™äº›åº”ç”¨ï¼Œä½†é€šè¿‡å°†è¿™äº›è§£å†³æ–¹æ¡ˆç½®äºé›¶çŸ¥è¯†ä¸­ï¼Œå¯ä»¥æé«˜æ•ˆç‡ã€‚

ç°åœ¨ï¼Œè¿˜æœ‰å¦ä¸€ç±»åº”ç”¨ï¼Œå¤§è‡´ä¸Šéœ€è¦æ›´å¤šçš„æ•°æ®è®¿é—®ï¼Œå› æ­¤éœ€è¦æ›´å¤šçš„è®¡ç®—ã€‚åœ¨æˆ‘çœ‹æ¥ï¼Œå¦‚æœä¸ä½¿ç”¨ ZK åå¤„ç†å™¨ï¼Œè¿™äº›åº”ç”¨æ˜¯æ— æ³•å®ç°çš„ã€‚

ä¸¾ä¸ªä¾‹å­ï¼Œä¸€ä¸ªæœ‰è¶£çš„åº”ç”¨æ˜¯å…è®¸ä»¥å¤ªåŠä¸Šçš„ Roll-up ä»¥ä¸€ç§å¯ä¿¡çš„æ–¹å¼è¯»å–åŸºç¡€å±‚æˆ–å¦ä¸€ä¸ª Roll-up çš„çŠ¶æ€ï¼Œä½¿ç”¨é›¶çŸ¥è¯†è¿›è¡Œäº¤äº’ã€‚å…¶ä¸­ä¸€ç§åº”ç”¨å¯èƒ½æ˜¯å…è®¸ Roll-up è¯»å– ERC20 ä»£å¸çš„å®Œæ•´ä½™é¢å¿«ç…§ã€‚

å¦‚æœæˆ‘ä»¬å°†ç›®å…‰ä»å­˜å‚¨è½¬å‘è´¦æˆ·çš„äº¤æ˜“å†å²ï¼Œä½ å¯ä»¥æƒ³è±¡é€šè¿‡è®°å½•ä»¥å¤ªåŠåœ°å€çš„å®Œæ•´å†å²ï¼Œæ„å»ºä¸€ä¸ªå¯ä¿¡çš„å£°èª‰ã€èº«ä»½æˆ–ä¿¡ç”¨è¯„åˆ†ç³»ç»Ÿã€‚è¿™å¯èƒ½ç”¨äºä¿¡ç”¨è¯„åˆ†ï¼Œæˆ–è€…ç”¨äºè®©ä½ è®¿é—®æŸç§ç±»å‹çš„é“¾ä¸Š DAOï¼Œæˆ–è€…ç”¨äºè®©ä½ è·å¾—è‡ªå®šä¹‰ NFT çš„å‘è¡Œæƒé™ã€‚

è¿˜æœ‰ä¸€ç±»åº”ç”¨ç¨‹åºæ˜¯ä½¿ç”¨é“¾ä¸Šçš„å†å²æ•°æ®æ¥å®é™…ç®¡ç†åè®®ã€‚ä¸€èˆ¬ç§°ä¸ºåè®®è®°è´¦ã€‚

è¿™é‡Œçš„æƒ³æ³•æ˜¯ï¼Œåè®®çš„å­˜åœ¨æ˜¯ä¸ºäº†åè°ƒå‚ä¸è€…çš„è¡Œä¸ºï¼Œè€Œåè°ƒçš„åŸºæœ¬åŸåˆ™æ˜¯èƒ½å¤Ÿå¯¹å‚ä¸è€…çš„è¡Œä¸ºè¿›è¡Œå¥–åŠ±æˆ–æƒ©ç½šã€‚å¦‚æœä½ è§‚å¯Ÿä»¥å¤ªåŠä¸Šçš„è®¸å¤šåè®®ï¼Œå‚ä¸è€…çš„è¡ŒåŠ¨è®°å½•å®é™…ä¸Šå®Œå…¨ä¿å­˜åœ¨é“¾ä¸Šã€‚å› æ­¤ï¼Œä½¿ç”¨ Axiomï¼Œæˆ‘ä»¬å¯ä»¥æƒ³è±¡æ ¹æ®åè®®å‚ä¸è€…çš„å®Œæ•´è¡ŒåŠ¨é›†åˆï¼Œåè®®å¯ä»¥ç¡®å®šæ”¯ä»˜ç»“æ„ï¼Œç”šè‡³å¯¹å‚ä¸è€…è¿›è¡ŒæŸç§ç±»å‹çš„æƒ©ç½šï¼Œæˆ‘ä»¬è®¤ä¸ºè¿™å¯ä»¥çœŸæ­£æ‰©å±•åè®®åº”ç”¨çš„è®¾è®¡ç©ºé—´ã€‚

æœ€åï¼Œå¦‚æœæˆ‘ä»¬çœŸæ­£æå‡è®¡ç®—çš„å±‚æ¬¡ï¼Œæˆ‘ä»¬è®¤ä¸ºä½¿ç”¨æœºå™¨å­¦ä¹ æ¨¡å‹æ¥è°ƒæ•´é“¾ä¸Šçš„å‚æ•°å¯èƒ½ä¼šéå¸¸æœ‰è¶£ã€‚å¦‚æœä½ æ€è€ƒä¼ ç»Ÿé‡‘èåº”ç”¨ï¼ŒåŸºäºå¤§é‡å†å²æ•°æ®è¿›è¡Œå¤æ‚çš„æœªæ¥å‚æ•°å»ºæ¨¡æ˜¯éå¸¸å¸¸è§çš„ï¼Œä¾‹å¦‚ä»·æ ¼æ•°æ®ã€ç»æµæ•°æ®ç­‰ã€‚è€Œå½“æˆ‘ä»¬çœ‹å½“å‰çš„ DeFiï¼Œè¿˜è¿œè¿œæ²¡æœ‰è¾¾åˆ°é‚£ä¸ªå±‚æ¬¡ã€‚æˆ‘å¹¶ä¸è®¤ä¸º DeFi åº”è¯¥ä¸ä¼ ç»Ÿé‡‘èå·¥ä½œæ–¹å¼å®Œå…¨ç›¸åŒï¼Œä½†æˆ‘ä»¬ç¡®å®è®¤ä¸ºæ³¨å…¥ä¸€äº›å†å²æ•°æ®åº“å’ŒåŸºäºæœºå™¨å­¦ä¹ çš„æ¨¡å‹å’Œä¿¡æ¯å¯èƒ½æœ‰åŠ©äºåˆ›å»ºæ›´å…·åŠ¨æ€æ€§çš„ DeF iåè®®ã€‚

è¿™äº›åªæ˜¯å…³äº Reflection æ“ä½œå¯ä»¥ä¸ºåŒºå—é“¾å¸¦æ¥çš„ä¸€äº›æƒ³æ³•ã€‚



Blockchain Capitalï¼šæˆ‘ä»¬ä¸ºä½•è¦é¢†æŠ•ZKåŸºç¡€è®¾æ–½å…¬å¸RISC Zeroçš„4000ä¸‡ç¾å…ƒèèµ„ï¼Ÿ
Bart Stephensã€Ryan Sprouleã€Yuan Han Li2023-07-20çƒ­åº¦: 8656

ZK å¤§è§„æ¨¡é‡‡ç”¨çš„å¦ä¸€ä¸ªå·¨å¤§éšœç¢æ˜¯ ZK ç³»ç»Ÿå›ºæœ‰çš„é«˜åº¦å¤æ‚çš„æ•°å­¦å’Œå¯†ç å­¦ã€‚

Copy code

åŸæ–‡ä½œè€…ï¼šBart Stephensã€Ryan Sprouleã€Yuan Han LiåŸæ–‡æ ‡é¢˜ï¼šDemocratizing Zero-Knowledge Computing: The Power of RISC Zeroâ€™s Bonsai NetworkåŸæ–‡æ¥æºï¼šzephyrnetç¼–è¯‘ï¼šZenï¼ŒPANews
7æœˆ19æ—¥ï¼Œæ—¨åœ¨å¸®åŠ©å¼€å‘è€…å¼€å‘é›¶è¯æ˜è½¯ä»¶çš„åŸºç¡€è®¾æ–½å…¬å¸ RISC Zero å®£å¸ƒå®Œæˆäº† 4000 ä¸‡ç¾å…ƒ A è½®èèµ„ï¼ŒBlockchain Capital é¢†æŠ•ï¼Œå‚æŠ•æ–¹åŒ…æ‹¬ Galaxy Digitalã€IOSGç­‰ã€‚ä½œä¸ºé¢†æŠ•æ–¹ï¼ŒBlockchain Capitalæ’°æ–‡åˆ†æäº†é›¶çŸ¥è¯†è®¡ç®—çš„å‘å±•ã€RISC Zeroçš„ç‰¹ç‚¹åŠä¼˜åŠ¿ï¼ŒPANewså¯¹å…¶è¿›è¡Œäº†ç¼–è¯‘ã€‚

æƒ³è±¡ä¸€ä¸‹è¿™æ ·ä¸€ä¸ªä¸–ç•Œ:æ•°æ®éšç§ã€å®‰å…¨å’Œä¿¡ä»»ä¸å†å—åˆ°å…³æ³¨ï¼Œè½¯ä»¶ä¾›åº”é“¾é€æ˜ä¸”å¯éªŒè¯ï¼Œæ–°ä¸€ä»£åº”ç”¨ç¨‹åºå¯ä»¥åˆ©ç”¨é›¶çŸ¥è¯†è®¡ç®—çš„åŠ›é‡æ¥è§£å†³æ•°å­—æ—¶ä»£ä¸€äº›æœ€ç´§è¿«çš„æŒ‘æˆ˜ã€‚è¿™æ˜¯é›¶çŸ¥è¯† (ZK) è®¡ç®—çš„æ‰¿è¯ºï¼Œä¹Ÿæ˜¯æˆ‘ä»¬æŠ•èµ„RISC Zeroçš„åŸå› ï¼Œè¿™æ˜¯ä¸€å®¶å¼€åˆ›æ€§çš„å…¬å¸ï¼Œæ—¨åœ¨é€šè¿‡å…¶ Bonsai ç½‘ç»œå®ç° ZK è®¿é—®çš„æ°‘ä¸»åŒ–ã€‚

é›¶çŸ¥è¯†è®¡ç®—æ˜¯ä¸€ç§é©å‘½æ€§çš„åŸè¯­ï¼Œå®ƒå…è®¸åº”ç”¨ç¨‹åºå’Œåè®®åˆ©ç”¨ç®€æ´æ€§ã€æ­£ç¡®æ€§å’Œé›¶çŸ¥è¯†è¿™ä¸‰ä¸ªå…³é”®å±æ€§ã€‚è¿™æ„å‘³ç€ï¼Œé€šè¿‡éªŒè¯ ZK è¯æ˜ï¼ˆæ­£ç¡®æ€§ï¼‰ï¼ŒéªŒè¯è€…å¯ä»¥é€šè¿‡è¿‘ä¹ç²¾ç¡®åœ°ä¿è¯çŸ¥é“è®¡ç®—å·²æ­£ç¡®æ‰§è¡Œã€‚

æ­¤å¤–ï¼Œç»è¿‡éªŒè¯çš„è¯æ˜å°†æ¯”åŸå§‹è®¡ç®—ç®€æ´å¾—å¤šï¼Œå¹¶ä¸”è¿˜å¯ä»¥åˆ©ç”¨è¯æ˜çš„é›¶çŸ¥è¯†å±æ€§æ¥ç¡®ä¿éªŒè¯è€…å¯¹è®¡ç®—æœ¬èº«ä¸€æ— æ‰€çŸ¥ã€‚è¿™ç§ç‹¬ç‰¹çš„å±æ€§ç»„åˆå…·æœ‰æ·±è¿œçš„å½±å“ï¼Œå¹¶æä¾›äº†ä¸€ç§éªŒè¯ä¿¡æ¯çš„æ–°æ–¹æ³•ã€‚è¿™äº›å±æ€§å…±åŒå¹³è¡¡äº†éšç§ã€å®‰å…¨å’Œä¿¡ä»»çš„éœ€æ±‚ï¼Œä¸ºæ›´å®‰å…¨ã€æ›´ç§å¯†çš„æ•°å­—ä¸–ç•Œæä¾›äº†æ½œåŠ›ã€‚ä½†åœ¨ ZK å……åˆ†å‘æŒ¥å…¶æ½œåŠ›ä¹‹å‰ï¼Œä»å­˜åœ¨ä¸€äº›éšœç¢ã€‚

é¦–å…ˆï¼Œåœ¨ ZK ä¸­è¿è¡Œè®¡ç®—è€—æ—¶å¤ªé•¿ä¸”æˆæœ¬å¤ªé«˜ã€‚è¯æ˜æ—¶é—´å’Œæˆæœ¬éœ€è¦å¤§å¹…ä¸‹é™ï¼Œæ‰èƒ½åœ¨ZKä¸­å®ç°å¤æ‚çš„è®¡ç®—ã€‚å¥½æ¶ˆæ¯æ˜¯è¿™äº›æ­£åœ¨æ€¥å‰§ä¸‹é™ï¼šZK è¯æ˜æ—¶é—´å’Œæˆæœ¬çš„è½¨è¿¹ä¸€ç›´éµå¾ªæŠ€æœ¯å²ä¸Šç†Ÿæ‚‰çš„è¶‹åŠ¿ - æ— è®ºæ˜¯æ‘©å°”å®šå¾‹ï¼ˆè®¡ç®—æˆæœ¬æ¯ä¸¤å¹´å‡åŠï¼‰ã€å¼—æ‹‰ç‰¹åˆ©å®šå¾‹ï¼ˆäººç±»åŸºå› ç»„æµ‹åºæˆæœ¬ä»¥æ›´æ˜¾ç€çš„é€Ÿåº¦ä¸‹é™ï¼‰è¿˜æ˜¯å…‹è±å¾·å®šå¾‹ï¼ˆç£ç›˜å¯†åº¦å¤§çº¦æ¯ 13 ä¸ªæœˆå¢åŠ ä¸€å€ï¼‰ã€‚è¯æ˜ç³»ç»Ÿï¼ˆPlonky2ã€Hyperplonkã€STARKï¼‰çš„æœ€æ–°æ¶æ„è¿›æ­¥ä»¥åŠåº•å±‚å¯†ç å­¦ï¼ˆPoseidonï¼‰çš„è¿›æ­¥é™ä½äº†åˆ›å»ºä»»ä½•è®¡ç®—çš„ ZK è¯æ˜æ‰€éœ€çš„å¼€é”€ã€‚è€Œè¿™äº›é¢†åŸŸçš„è¿›æ­¥å°†ç»§ç»­ä»¥ç±»ä¼¼çš„é€Ÿåº¦å‘ç”Ÿ(ç‰¹åˆ«æ˜¯æœ€è¿‘äººæ‰æ¶Œå…¥ZK)ï¼Œè¯æ˜ç®¡ç†è´¹ç”¨ä¹Ÿå°†å—ç›Šäºç¡¬ä»¶åŠ é€Ÿ(MSM, NTT)çš„è¿›æ­¥ï¼Œè¿™æ˜¯è¿„ä»Šä¸ºæ­¢å°šæœªå¾—åˆ°å……åˆ†å¼€å‘çš„ä¸œè¥¿ã€‚

ZK å¤§è§„æ¨¡é‡‡ç”¨çš„å¦ä¸€ä¸ªå·¨å¤§éšœç¢æ˜¯ ZK ç³»ç»Ÿå›ºæœ‰çš„é«˜åº¦å¤æ‚çš„æ•°å­¦å’Œå¯†ç å­¦ã€‚æ¨åŠ¨ZKåˆ›æ–°æ‰€éœ€çš„æ·±åº¦å’Œä¸“ä¸šçŸ¥è¯†æ°´å¹³åªæœ‰ä¸€å°éƒ¨åˆ†é«˜æŠ€èƒ½çš„æŠ€æœ¯å¼€å‘äººå‘˜èƒ½å¤Ÿèƒœä»»ã€‚

ç†æƒ³æƒ…å†µä¸‹ï¼Œå¼€å‘äººå‘˜å¯ä»¥è‡ªç”±åœ°ç”¨è‡ªå·±å–œæ¬¢çš„è¯­è¨€ç¼–å†™ç¨‹åºï¼ŒåŒæ—¶ä»ç„¶èƒ½å¤Ÿä»¥é›¶çŸ¥è¯†è¯æ˜è®¡ç®—ï¼Œè€Œæ— éœ€ä½¿ç”¨ä½çº§ã€ZK ç‰¹å®šçš„ç¼–ç¨‹è¯­è¨€å»æ‰‹å†™è¾“å…¥å’Œè®¾è®¡ç”µè·¯ã€‚è¿™å°±æ˜¯ RISC Zero çš„ Bonsai å¹³å°æˆä¸ºå…¨çƒå¼€å‘è€…æ¸¸æˆè§„åˆ™æ”¹å˜è€…çš„åœ°æ–¹ï¼Œä¹Ÿæ˜¯æˆ‘ä»¬æŠ•èµ„ RISC Zero çš„åŸå› ã€‚

é€šè¿‡åˆ›å»ºæ¨¡æ‹Ÿ RISC-V æŒ‡ä»¤é›†æ¶æ„ (ISA) çš„é›¶çŸ¥è¯†è™šæ‹Ÿæœº (zkVM)ï¼ŒRISC Zero æ„å»ºäº†ä¸€ä¸ªèƒ½å¤Ÿè¯æ˜ä½çº§ä»£ç æ‰§è¡Œçš„ç³»ç»Ÿã€‚ç”±äº ISA æ˜¯äººç±»å¯è¯»ä»£ç å’Œæœºå™¨å¯è§£é‡ŠæŒ‡ä»¤ä¹‹é—´çš„æ¡¥æ¢ï¼Œè¿™ä¸€æˆå°±æ„å‘³ç€Bonsaiç½‘ç»œå¯ä»¥è¯æ˜ä»»ä½•é«˜çº§ç¨‹åºéƒ½å¯ä»¥è¢«ç¼–è¯‘æˆè¿™ç§ä½“ç³»ç»“æ„ã€‚ç”±äºå¤§å¤šæ•°ç°ä»£ç¼–ç¨‹è¯­è¨€éƒ½ä¸ RISC-V å…¼å®¹ï¼ŒRISC Zero çš„ Bonsai èƒ½å¤Ÿä»¥é›¶çŸ¥è¯†æ‰§è¡Œå‡ ä¹ä»»ä½•ä»»æ„è®¡ç®—æœºç¨‹åºã€‚

åœ¨é›¶çŸ¥è¯†ï¼ˆZKï¼‰è®¡ç®—å˜å¾—æ™®éçš„æœªæ¥ï¼Œè®¸å¤šä»¥å‰ä¸å¯èƒ½çš„åº”ç”¨ç¨‹åºå°†æˆä¸ºå¯èƒ½ã€‚è¿™ä¸ä»…åŒ…æ‹¬åŸºäºä»¥å¤ªåŠçš„åº”ç”¨ç¨‹åºï¼Œåˆ©ç”¨RISC Zeroçš„ç›†æ™¯ç½‘ç»œä½œä¸ºåå¤„ç†å™¨(åœ¨éªŒè¯é“¾ä¸Šç»“æœä¹‹å‰æ‰§è¡Œèµ„æºå¯†é›†å‹çš„é“¾ä¸‹å·¥ä½œ)ï¼Œè¿˜å°†æ‰©å±•åˆ°åŠ å¯†è´§å¸ä»¥å¤–çš„åº”ç”¨ç¨‹åºã€‚ä¾‹å¦‚ï¼ŒBonsaiå¯ä»¥è®©ç™½å¸½é»‘å®¢åœ¨ä¸ç›´æ¥æŠ«éœ²æ¼æ´çš„æƒ…å†µä¸‹è¯æ˜å®‰å…¨æ¼æ´å’Œé”™è¯¯çš„å­˜åœ¨ã€‚å®ƒè¿˜å¯ä»¥é€šè¿‡å…è®¸ç”¨æˆ·ä¸‹è½½å’ŒéªŒè¯ZKè¯æ˜æ¥ç¡®ä¿ä»–ä»¬è¿è¡Œçš„ä»£ç åœ¨Bonsaiä¸­é¢„å…ˆå®¡è®¡ï¼Œä»è€Œé˜²æ­¢æœªæ¥å¯¹è½¯ä»¶çš„ä¾›åº”é“¾æ”»å‡»ã€‚æœ€ä»¤äººå…´å¥‹çš„æ˜¯ï¼ŒBonsaiçš„å¹¿æ³›é‡‡ç”¨å¯èƒ½ä¼šå¸¦æ¥å°šæœªæƒ³è±¡åˆ°çš„å…¨æ–°ç”¨ä¾‹ã€‚

é™¤äº†ä»¤äººå°è±¡æ·±åˆ»çš„æŠ€æœ¯çªç ´ä¹‹å¤–ï¼ŒRISC ZeroèƒŒåè¿˜æœ‰ç€å¼ºå¤§è€Œç‹¬ç‰¹çš„å›¢é˜Ÿã€‚ä¸‰ä½è”åˆåˆ›å§‹äººBrian Retfordã€Jeremy Bruestleå’ŒFrank Laubå·²å½¼æ­¤ç›¸è¯† 20 å¤šå¹´ã€‚ä»–ä»¬å…±æœ‰çš„ç»å†åŒ…æ‹¬å…±åŒåˆ›å»ºå¤šå®¶å…¬å¸ï¼Œå…¶ä¸­æœ€è¿‘çš„ä¸€å®¶å…¬å¸æ¶‰è¶³äººå·¥æ™ºèƒ½ä¼˜åŒ–å’Œç¼–è¯‘é¢†åŸŸï¼Œæœ€ç»ˆè¢«è‹±ç‰¹å°”æ”¶è´­ã€‚

ä¸‰äººç»„çš„æ¯ä½æˆå‘˜éƒ½ä¸º RISC Zero å¸¦æ¥äº†ä¸°å¯Œçš„ç»éªŒï¼šBrian æ›¾åœ¨ Google Cloud Platform ä»äº‹å®šä»·å’Œè®¡é‡ç³»ç»Ÿå·¥ä½œï¼›Jeremy æ˜¯ä¸€ä½ç»ˆç”Ÿçš„æ•°å­¦çˆ±å¥½è€…ï¼Œè‡´åŠ›äºåŸºå› æµ‹åºçš„ GPU åŠ é€Ÿï¼Œå¹¶æ‹¥æœ‰å¯†ç å­¦ã€é«˜æ€§èƒ½è®¡ç®—ï¼ˆHPCï¼‰ å’Œå®‰å…¨æ–¹é¢çš„èƒŒæ™¯ï¼›Frank åœ¨ç¼–è¯‘å™¨æ–¹é¢æ‹¥æœ‰æ·±åšçš„èƒŒæ™¯ï¼Œå¹¶æ„å»ºäº†ä¼—å¤šä»£ç åº“ã€‚å‡­å€Ÿå…±åŒçš„å†å²å’Œå¤šæ ·åŒ–çš„æŠ€èƒ½ï¼ŒRISC Zeroå›¢é˜Ÿå…·æœ‰ç‹¬ç‰¹çš„ä¼˜åŠ¿ï¼Œä»–ä»¬å‘å¤§ä¼—æä¾›é›¶çŸ¥è¯†è®¡ç®—ï¼Œå¹¶æœ‰å¯èƒ½åœ¨æ­¤è¿‡ç¨‹ä¸­é‡å¡‘æ•°å­—æ ¼å±€ã€‚

å½“æˆ‘ä»¬å±•æœ›é›¶çŸ¥è¯†è®¡ç®—å¹¿æ³›æ™®åŠçš„æœªæ¥æ—¶ï¼Œåˆ›æ–°çš„å¯èƒ½æ€§æ˜¯æ— é™çš„ã€‚RISC Zero çš„ Bonsai ç½‘ç»œèƒ½å¤Ÿæ”¯æŒå¹¿æ³›çš„ç¼–ç¨‹è¯­è¨€ï¼Œå°†ä½¿ ZK è®¡ç®—æ°‘ä¸»åŒ–ï¼Œå¹¶ä½¿å¼€å‘äººå‘˜èƒ½å¤Ÿåœ¨å„ä¸ªé¢†åŸŸåˆ›å»ºå®‰å…¨ã€ç§æœ‰å’Œæ— éœ€ä¿¡ä»»çš„åº”ç”¨ç¨‹åºã€‚ä»åŠ å¼ºç½‘ç»œå®‰å…¨æªæ–½åˆ°å¢å¼ºå¯¹è½¯ä»¶ä¾›åº”é“¾çš„ä¿¡ä»»ï¼Œå†åˆ°å¤§å¹…æé«˜é“¾ä¸Šåº”ç”¨ç¨‹åºå¯ç”¨çš„è®¡ç®—èƒ½åŠ›ï¼Œé›¶çŸ¥è¯†è®¡ç®—çš„æ½œåœ¨å½±å“æ˜¯å·¨å¤§çš„ã€‚å¿«é€Ÿä¸‹é™çš„ ZK è¯æ˜æ—¶é—´å’Œæˆæœ¬ã€RISC Zero çš„å¿ è¯šå›¢é˜Ÿä»¥åŠ Bonsai ä½œä¸ºå¤šåŠŸèƒ½è®¡ç®—å¹³å°çš„å‡ºç°ï¼Œé¢„ç¤ºç€è®¡ç®—çš„æ–°æ—¶ä»£â€”â€”éšç§ã€å®‰å…¨å’Œä¿¡ä»»è¢«æ„å»ºåˆ°æˆ‘ä»¬æ•°å­—ä¸–ç•Œçš„ç»“æ„ä¸­ã€‚